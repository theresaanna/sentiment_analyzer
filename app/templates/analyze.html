{% extends "base.html" %}

{% block title %}Analysis Results - VibeCheckAI{% endblock %}

{% block extra_css %}
<style>
    .sentiment-card {
        transition: transform 0.2s;
    }
    .sentiment-card:hover {
        transform: translateY(-5px);
    }
    .progress-container {
        min-height: 200px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .analysis-section {
        display: none;
    }
    .analysis-section.active {
        display: block;
    }
    .sentiment-positive { color: #28a745; }
    .sentiment-negative { color: #dc3545; }
    .sentiment-neutral { color: #6c757d; }
    
    /* Pulse animation for analyze button */
    .pulse-animation {
        animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
        0% {
            transform: scale(1);
            box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.7);
        }
        70% {
            transform: scale(1.05);
            box-shadow: 0 0 0 10px rgba(0, 123, 255, 0);
        }
        100% {
            transform: scale(1);
            box-shadow: 0 0 0 0 rgba(0, 123, 255, 0);
        }
    }
    
    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    /* Updated stats highlighting */
    .updated-badge {
        animation: fadeIn 0.5s ease-in-out;
    }
    
    .stats-value.updated {
        animation: pulse 1s ease-in-out;
        color: #10b981 !important;
        transition: color 0.3s ease;
    }
    
    /* Free analysis button styling */
    .vibe-button.free-analysis {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        font-size: 1.1rem;
        padding: 14px 28px;
    }
    
    .free-analysis-info {
        background: linear-gradient(135deg, #f8f9ff 0%, #f0f4ff 100%);
        border: 2px solid #e0e7ff;
        border-radius: 12px;
        padding: 12px 20px;
        margin-top: 15px;
        font-size: 0.95rem;
    }
    
    .free-analysis-info strong {
        color: #5a67d8;
        font-size: 1rem;
    }
    
    .free-analysis-info small {
        display: block;
        margin-top: 5px;
        color: #6b7280;
    }
    
    /* Word cloud controls */
    .word-cloud-controls {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 15px;
    }
    
    .zoom-controls {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
    }
    
    .zoom-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
    }
    
    /* Enhanced summary styling */
    #aiSummary {
        font-size: 16px;
        line-height: 1.6;
    }
    
    #aiSummary .alert, #aiSummary .card {
        font-size: 15px;
    }
    
    #aiSummary .theme-content .badge {
        font-size: 13px;
        padding: 5px 10px;
        margin-right: 5px;
    }
    
    #aiSummary .blockquote-sm {
        font-size: 14px;
        border-left: 3px solid #dee2e6;
        padding-left: 10px;
    }
    
    #aiSummary .controversy-content {
        font-size: 14px;
    }
    
    #aiSummary ul li {
        margin-bottom: 8px;
    }
    
    .alert-heading {
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 10px;
    }
    
    .card-title {
        font-size: 16px;
        font-weight: 600;
    }
    
    /* Compact stats card styling */
    .stats-card {
        padding: 0.75rem;
    }
    
    .stats-card .stats-value {
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1;
        margin-bottom: 0.25rem;
        white-space: nowrap;
    }
    
    .stats-card .stats-label {
        font-size: 0.875rem;
        color: #6c757d;
        margin-bottom: 0;
        white-space: nowrap;
    }
    
    .stats-card .stats-icon {
        font-size: 0.75rem;
        margin-right: 0.25rem;
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
        .stats-card .stats-value {
            font-size: 1.25rem;
        }
        .stats-card .stats-label {
            font-size: 0.8rem;
        }
    }
    
    /* Toast animation */
    @keyframes slideIn {
        from {
            transform: translateX(100%);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
    
    /* Manually corrected comment styles */
    .comment-sample-item.manually-corrected {
        background: linear-gradient(135deg, #f0f4f8 0%, #e8ecf0 100%);
        border: 2px solid #94a3b8;
        position: relative;
    }
    
    .manual-correction-badge {
        position: absolute;
        top: 8px;
        right: 8px;
        background: #3b82f6;
        color: white;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 4px;
    }
    
    .correction-info {
        background: #f8fafc;
        border: 1px solid #cbd5e1;
        border-radius: 6px;
        padding: 8px 12px;
        margin-top: 10px;
        font-size: 0.85rem;
    }
    
    .correction-info .original-prediction {
        text-decoration: line-through;
        opacity: 0.6;
        color: #64748b;
    }
    
    .correction-info .user-correction {
        color: #059669;
        font-weight: 600;
        margin-left: 8px;
    }
    
    .feedback-btn.disabled-original {
        opacity: 0.4;
        text-decoration: line-through;
        cursor: not-allowed;
        background: #e2e8f0;
    }
    
    .feedback-btn.highlighted-correction {
        background: #10b981;
        color: white;
        font-weight: 600;
        box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2);
    }
    
    @media (max-width: 576px) {
        .stats-card {
            padding: 0.5rem;
        }
        .stats-card .stats-value {
            font-size: 1.1rem;
        }
    }
    
    /* Word cloud responsive styling */
    #wordCloudContainer {
        overflow-x: auto;
        overflow-y: hidden;
    }
    
    #wordCloud {
        display: block;
        margin: 0 auto;
        background: linear-gradient(135deg, #f5f7fa 0%, #f8f9ff 100%);
    }
    
    /* Key Discussion Themes enhanced styling */
    .theme-grid {
        margin-top: 1rem;
    }
    
    .theme-item {
        background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
        border: 1px solid #e3e6f0;
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 10px;
        transition: all 0.3s ease;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    .theme-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        border-color: #c3c9e0;
    }
    
    .theme-item .badge {
        font-size: 16px;
        padding: 8px 14px;
        margin-right: 12px;
        font-weight: 700;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .theme-item strong {
        font-size: 22px;
        font-weight: 600;
        letter-spacing: 0.5px;
    }
    
    /* Color differentiation for high vs moderate relevance */
    .theme-item-high strong {
        color: #6f42c1;
        background: linear-gradient(90deg, #6f42c1, #8b5cf6);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }
    
    .theme-item-moderate strong {
        color: #4c6ef5;
        background: linear-gradient(90deg, #4c6ef5, #5a67d8);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }
    
    .badge-danger {
        background: linear-gradient(135deg, #8b5cf6 0%, #6f42c1 100%);
        border: none;
    }
    
    .badge-warning {
        background: linear-gradient(135deg, #5a67d8 0%, #4c6ef5 100%);
        border: none;
    }
    
    /* Mobile responsive for themes */
    @media (max-width: 768px) {
        .theme-item strong {
            font-size: 20px;
        }
        .theme-item .badge {
            font-size: 14px;
            padding: 6px 10px;
        }
        .theme-item {
            padding: 10px 14px;
        }
    }
    
    @media (max-width: 576px) {
        .theme-item strong {
            font-size: 18px;
        }
        .theme-item .badge {
            font-size: 13px;
            padding: 5px 8px;
        }
    }
    
    /* Scrollable comment samples */
    .comment-samples-container {
        height: 450px;
        overflow-y: auto;
        overflow-x: hidden;
        padding-right: 10px;
        scrollbar-width: thin;
        scrollbar-color: #cbd5e0 #f7fafc;
        background: linear-gradient(to bottom, #f8f9fa 0%, #f0f2f5 100%);
        border-radius: 0 0 8px 8px;
        padding: 10px;
        border: 1px solid #e9ecef;
        border-top: none;
    }
    
    /* Sample comments body padding */
    #sampleCommentsSection .card-body {
        padding: 1.5rem;
    }
    
    /* Make sample comments section wider on larger screens */
    /* Responsive padding adjustments */
    @media (min-width: 1200px) {
        #sampleCommentsSection .card-body {
            padding: 2rem;
        }
    }
    
    @media (min-width: 1400px) {
        #sampleCommentsSection .card-body {
            padding: 2.5rem;
        }
    }
    
    /* Separate visual styling for the sample comments section - now using vibe-card */
    #sampleCommentsSection {
        margin-top: 2rem;
    }
    
    /* Sample Comments header uses default vibe-card styling */
    
    .comment-samples-container::-webkit-scrollbar {
        width: 8px;
    }
    
    .comment-samples-container::-webkit-scrollbar-track {
        background: #f7fafc;
        border-radius: 4px;
    }
    
    .comment-samples-container::-webkit-scrollbar-thumb {
        background: #cbd5e0;
        border-radius: 4px;
    }
    
    .comment-samples-container::-webkit-scrollbar-thumb:hover {
        background: #a0aec0;
    }
    
    .comment-sample-item {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 8px;
        padding: 14px;
        margin-bottom: 14px;
        transition: all 0.2s ease;
    }
    
    .comment-sample-item:hover {
        background: white;
        border-color: #dee2e6;
        transform: translateX(2px);
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    .comment-sample-text {
        font-size: 0.95rem;
        line-height: 1.6;
        margin-bottom: 10px;
        word-wrap: break-word;
        color: #2d3748;
    }
    
    .comment-sample-meta {
        font-size: 0.8rem;
        color: #6c757d;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .confidence-badge {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 2px 8px;
        border-radius: 12px;
        font-weight: 600;
        font-size: 0.75rem;
    }
    
    .comment-sample-item.positive {
        border-left: 3px solid #28a745;
    }
    
    .comment-sample-item.negative {
        border-left: 3px solid #dc3545;
    }
    
    .comment-sample-item.neutral {
        border-left: 3px solid #6c757d;
    }
    
    /* Sentiment headers styling */
    .sentiment-header-section {
        background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
        border-radius: 8px 8px 0 0;
        padding: 12px 16px;
        margin-bottom: 0;
        border: 1px solid #d1d5db;
        border-bottom: 2px solid #9ca3af;
    }
    
    .sentiment-header-section h5 {
        margin: 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 1.2rem;
    }
    
    .sentiment-positive.sentiment-header-section {
        background: linear-gradient(135deg, #d4edda 0%, #f4f9f5 100%);
        border-color: #c3e6cb;
    }
    
    .sentiment-neutral.sentiment-header-section {
        background: linear-gradient(135deg, #e2e3e5 0%, #f8f9fa 100%);
        border-color: #d6d8db;
    }
    
    .sentiment-negative.sentiment-header-section {
        background: linear-gradient(135deg, #f8d7da 0%, #fff5f5 100%);
        border-color: #f5c6cb;
    }
    
    /* Feedback buttons styling */
    .feedback-buttons {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-top: 8px;
    }
    
    .feedback-btn {
        background: none;
        border: 1px solid #dee2e6;
        border-radius: 16px;
        padding: 4px 10px;
        font-size: 0.75rem;
        cursor: pointer;
        transition: all 0.2s;
        display: inline-flex;
        align-items: center;
        gap: 4px;
        color: #6c757d;
    }
    
    .feedback-btn:hover:not(.current-sentiment) {
        background: #f8f9fa;
        border-color: #adb5bd;
        transform: scale(1.05);
    }
    
    .feedback-btn.current-sentiment {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-color: #667eea;
        cursor: default;
        font-weight: 600;
    }
    
    .feedback-btn.positive:hover:not(.current-sentiment) {
        border-color: #28a745;
        color: #28a745;
    }
    
    .feedback-btn.neutral:hover:not(.current-sentiment) {
        border-color: #6c757d;
        color: #495057;
    }
    
    .feedback-btn.negative:hover:not(.current-sentiment) {
        border-color: #dc3545;
        color: #dc3545;
    }
    
    .feedback-notice {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 12px;
        margin-top: 12px;
        font-size: 0.85rem;
        color: #6c757d;
        text-align: center;
    }
    
    .feedback-notice i {
        color: #667eea;
        margin-right: 4px;
    }
    
    @keyframes fadeOutUp {
        from {
            opacity: 1;
            transform: translateY(0);
        }
        to {
            opacity: 0;
            transform: translateY(-20px);
        }
    }
    
    .comment-sample-item.removing {
        animation: fadeOutUp 0.5s ease-out;
    }
</style>
{% endblock %}

{% block content %}
<div class="analyze-page">
    <div class="container">
        {% if success %}
        <!-- Video Embed and Info -->
        <div class="vibe-card mb-4">
            <div class="card-header-vibe">
                <h3 class="mb-0">
                    <span class="emoji-icon">📺</span> {{ video_info.title }}
                </h3>
            </div>
            <div class="card-body">
                <!-- Video Embed -->
                <div class="embed-responsive embed-responsive-16by9 mb-4">
                    <iframe class="embed-responsive-item" 
                            src="https://www.youtube.com/embed/{{ video_id }}"
                            allowfullscreen></iframe>
                </div>
                
                <!-- Video Metadata -->
                <div class="row mb-3">
                    <div class="col-md-6">
                        <p><strong><i class="fas fa-tv"></i> Channel:</strong> {{ video_info.channel }}</p>
                        <p><strong><i class="fas fa-calendar"></i> Published:</strong> {{ video_info.published_at[:10] }}</p>
                        <p><strong><i class="fas fa-clock"></i> Duration:</strong> {{ video_info.duration | format_duration }}</p>
                    </div>
                    <div class="col-md-6">
                        <p><strong><i class="fas fa-link"></i> URL:</strong> <a href="{{ video_url }}" target="_blank" rel="noopener">Watch on YouTube</a></p>
                        <p><strong><i class="fas fa-hashtag"></i> Video ID:</strong> <code>{{ video_id }}</code></p>
                    </div>
                </div>
                
                <!-- Video Statistics Cards -->
                <div class="row">
                    <div class="col-md-6 col-sm-6 mb-3">
                        <div class="card bg-light">
                            <div class="card-body stats-card">
                                <div class="stats-value text-primary">{{ "{:,}".format(video_info.statistics.views) }}</div>
                                <p class="stats-label"><i class="fas fa-eye stats-icon"></i>Views</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 col-sm-6 mb-3">
                        <div class="card bg-light">
                            <div class="card-body stats-card">
                                <div class="stats-value text-success">{{ "{:,}".format(video_info.statistics.likes) }}</div>
                                <p class="stats-label"><i class="fas fa-thumbs-up stats-icon"></i>Likes</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 col-sm-6 mb-3">
                        <div class="card bg-light">
                            <div class="card-body stats-card">
                                <div class="stats-value text-info">{{ "{:,}".format(video_info.statistics.comments) }}</div>
                                <p class="stats-label"><i class="fas fa-comment stats-icon"></i>Comments</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 col-sm-6 mb-3">
                        <div class="card bg-light">
                            <div class="card-body stats-card">
                                <div class="stats-value text-warning">{{ "%.1f%%"|format((video_info.statistics.likes / video_info.statistics.views * 100) if video_info.statistics.views > 0 else 0) }}</div>
                                <p class="stats-label"><i class="fas fa-percentage stats-icon"></i>Engagement</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Comment Analysis -->
        <div class="vibe-card mb-4">
            <div class="card-header-vibe">
                <h3 class="mb-0">
                    <span class="emoji-icon">💬</span> Comment Analysis
                </h3>
            </div>
            <div class="card-body">
                <div class="alert alert-info mb-4">
                    <i class="fas fa-info-circle"></i> 
                    Fetched <strong>{{ comment_stats.total_comments }}</strong> of <strong>{{ "{:,}".format(comment_stats.total_available) }}</strong> available comments 
                    (<strong>{{ "%.1f"|format(comment_stats.fetch_percentage) }}%</strong> coverage)
                    <br>
                    <small class="text-muted">
                        <i class="fas fa-clock"></i> Fetch time: {{ "%.1f"|format(comment_stats.fetch_time) }}s | 
                        <i class="fas fa-tachometer-alt"></i> Speed: {{ "%.0f"|format(comment_stats.comments_per_second) }} comments/sec
                    </small>
                    {% if not current_user.is_authenticated %}
                    <div class="pro-analysis-message">
                        <div class="d-flex align-items-center">
                            <i class="fas fa-star mr-2"></i>
                            <small class="text-primary font-weight-bold">
                                📈 <strong>Pro Analysis</strong> can fetch up to 100% of comments with advanced filtering and prioritization. 
                                <a href="{{ url_for('auth.login') }}">Sign in</a> or 
                                <a href="{{ url_for('auth.subscribe') }}">upgrade to Pro</a> 
                                for comprehensive comment coverage.
                            </small>
                        </div>
                    </div>
                    {% elif not current_user.is_subscribed %}
                    <div class="pro-analysis-message">
                        <div class="d-flex align-items-center">
                            <i class="fas fa-star mr-2"></i>
                            <small class="text-primary font-weight-bold">
                                📈 <strong>Pro Analysis</strong> can fetch up to 100% of comments with adjustable depth and advanced filtering. 
                                <a href="{{ url_for('auth.subscribe') }}">Upgrade to Pro</a> 
                                to maximize comment coverage and get deeper insights.
                            </small>
                        </div>
                    </div>
                    {% endif %}
                </div>
                
                <!-- Comment Statistics Cards -->
                <div class="row mb-4">
                    <div class="col-md-6 col-sm-6 mb-3">
                        <div class="card bg-light">
                            <div class="card-body stats-card">
                                <div class="stats-value text-primary">{{ comment_stats.unique_commenters }}</div>
                                <p class="stats-label"><i class="fas fa-users stats-icon"></i>Unique Commenters</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 col-sm-6 mb-3">
                        <div class="card bg-light">
                            <div class="card-body stats-card">
                                <div class="stats-value text-success">{{ comment_stats.avg_comment_length }}</div>
                                <p class="stats-label"><i class="fas fa-text-width stats-icon"></i>Avg Length</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 col-sm-6 mb-3">
                        <div class="card bg-light">
                            <div class="card-body stats-card">
                                <div class="stats-value text-info">{{ comment_stats.top_level_count }}</div>
                                <p class="stats-label"><i class="fas fa-comment-dots stats-icon"></i>Top-level</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 col-sm-6 mb-3">
                        <div class="card bg-light">
                            <div class="card-body stats-card">
                                <div class="stats-value text-warning">{{ comment_stats.replies_count }}</div>
                                <p class="stats-label"><i class="fas fa-reply stats-icon"></i>Replies</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Top Commenters -->
                {% if comment_stats.top_commenters %}
                <div class="card bg-light mb-3">
                    <div class="card-header">
                        <h5 class="mb-0"><i class="fas fa-trophy"></i> Most Active Commenters</h5>
                    </div>
                    <div class="card-body">
                        <ol class="list-group list-group-flush">
                            {% for author, count in comment_stats.top_commenters %}
                            <li class="list-group-item d-flex justify-content-between align-items-center">
                                <span><strong>#{{ loop.index }}</strong> {{ author }}</span>
                                <span class="badge badge-primary badge-pill">{{ count }} comments</span>
                            </li>
                            {% endfor %}
                        </ol>
                    </div>
                </div>
                {% endif %}
                
                <!-- Sentiment Analysis CTA -->
                <div class="text-center">
                    <!-- Analysis Coverage Section -->
                    <div class="coverage-card mb-4">
                        <div class="coverage-header">
                            <h5 class="coverage-title">
                                <span class="coverage-icon">📊</span>
                                Analysis Coverage
                                {% if not (current_user.is_authenticated and current_user.is_subscribed) %}
                                    <span class="pro-badge-inline">PRO</span>
                                {% endif %}
                            </h5>
                        </div>
                        
                        <div class="coverage-body">
                            {% if not (current_user.is_authenticated and current_user.is_subscribed) %}
                                <!-- Locked State for Free Users -->
                                <div class="coverage-locked">
                                    <div class="locked-overlay">
                                        <span class="lock-icon">🔒</span>
                                        <h6>Premium Feature: Choose Your Analysis Depth</h6>
                                        <p class="mb-2"><strong>Free users:</strong> 10% sample analysis (up to 100 comments)</p>
                                        <p class="mb-3"><strong>Pro users:</strong> Analyze 10% to 100% of all comments</p>
                                        <a href="{{ url_for('auth.subscribe') }}" class="vibe-button small">
                                            <span class="button-icon">⭐</span>
                                            <span class="button-text">Upgrade to Pro - $10/month</span>
                                        </a>
                                    </div>
                                    <div class="coverage-preview locked">
                                        <div class="slider-container">
                                            <label class="slider-label">Analysis Depth <span style="color: #10b981; font-weight: 600;">(Free: 10%)</span></label>
                                            <input type="range" class="coverage-slider" disabled value="10">
                                            <div class="slider-values">
                                                <span style="color: #10b981; font-weight: 600;">10% ✓</span>
                                                <span class="current-value">50%</span>
                                                <span>100%</span>
                                            </div>
                                        </div>
                                        <div class="coverage-stats">
                                            <div class="stat-badge locked">
                                                <span class="stat-label">Comments</span>
                                                <span class="stat-value" style="color: #10b981; font-weight: 600;">{{ [comment_stats.total_comments * 0.1, 100]|min|int }}</span>
                                            </div>
                                            <div class="stat-badge locked">
                                                <span class="stat-label">Time</span>
                                                <span class="stat-value">~{{ (([comment_stats.total_comments * 0.1, 100]|min / 100) * 2)|round(1) }}s</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            {% else %}
                                <!-- Unlocked State for Pro Users -->
                                <div class="coverage-unlocked">
                                    <div class="slider-container">
                                        <label class="slider-label">
                                            Analysis Depth
                                            {% if comment_stats.fetched_comments > 0 %}
                                                <span class="badge badge-success ml-2" style="font-size: 0.8rem;">
                                                    <i class="fas fa-check-circle"></i> {{ comment_stats.fetched_comments }} preloaded
                                                </span>
                                            {% endif %}
                                        </label>
                                        <input type="range" 
                                               class="coverage-slider" 
                                               id="commentPercentageSlider" 
                                               min="10" 
                                               max="100" 
                                               step="10" 
                                               value="50">
                                        <div class="slider-values">
                                            <span>10%</span>
                                            <span class="current-value" id="percentageDisplay">50%</span>
                                            <span>100%</span>
                                        </div>
                                    </div>
                                    <div class="coverage-stats">
                                        <div class="stat-badge">
                                            <span class="stat-label">Comments</span>
                                            <span class="stat-value" id="commentCountEstimate">{{ (comment_stats.total_comments * 0.5)|int }}</span>
                                        </div>
                                        <div class="stat-badge">
                                            <span class="stat-label">Est. Time</span>
                                            <span class="stat-value" id="timeEstimate">~{{ ((comment_stats.total_comments * 0.5 / 100) * 2)|round(1) }}s</span>
                                        </div>
                                        <div class="stat-badge">
                                            <span class="stat-label">Accuracy</span>
                                            <span class="stat-value" id="accuracyEstimate">Good</span>
                                        </div>
                                    </div>
                                    <p class="coverage-tip">
                                        <span class="tip-icon">💡</span>
                                        <span id="coverageTip">Balanced analysis - recommended for most use cases</span>
                                    </p>
                                </div>
                            {% endif %}
                        </div>
                    </div>
                    
                    {% if not (current_user.is_authenticated and current_user.is_subscribed) %}
                        <!-- Free User CTA -->
                        <button id="startSentimentAnalysisMain" class="vibe-button free-analysis pulse-animation">
                            <span class="button-icon">🧠</span>
                            <span class="button-text">Start Free Analysis</span>
                        </button>
                        <div class="free-analysis-info">
                            <strong>✨ Try VibeCheckAI Free!</strong>
                            Your free analysis will include:
                            <ul class="mb-0 mt-2" style="padding-left: 20px;">
                                <li>Up to <strong>{{ [comment_stats.total_comments * 0.1, 100]|min|int }}</strong> comments (10% sample, max 100)</li>
                                <li>Full sentiment breakdown & charts</li>
                                <li>AI-powered summary & insights</li>
                                <li>Key discussion themes analysis</li>
                            </ul>
                            <small>
                                <a href="{{ url_for('auth.subscribe') }}" style="color: #5a67d8; text-decoration: underline;">
                                    Upgrade to Pro</a> to analyze all {{ comment_stats.total_comments }} comments with adjustable depth
                            </small>
                        </div>
                    {% else %}
                        <!-- Pro User CTA -->
                        <button id="startSentimentAnalysisMain" class="vibe-button pulse-animation">
                            <span class="button-icon">🧠</span>
                            <span class="button-text">Analyze Sentiment</span>
                        </button>
                        <p class="text-muted mt-2 mb-0">Get AI-powered insights into the emotional tone of these comments</p>
                    {% endif %}
                </div>
            </div>
        </div>
        
        <!-- Sentiment Analysis Section -->
        <div id="sentimentAnalysisSection" class="vibe-card mb-4 analysis-section" style="display: none;">
            <div class="card-header-vibe d-flex justify-content-between align-items-center">
                <h3 class="mb-0">
                    <span class="emoji-icon">🧠</span> Sentiment Analysis
                </h3>
                <button id="startSentimentAnalysis" class="vibe-button small">
                    <span class="button-icon">🧠</span>
                    <span class="button-text">Analyze Sentiment</span>
                </button>
            </div>
            <div class="card-body">
                <!-- Progress Section -->
                <div id="analysisProgress" class="progress-container">
                    <div class="text-center">
                        <div class="spinner-border text-primary mb-3" role="status">
                            <span class="sr-only">Loading...</span>
                        </div>
                        <h5 id="progressStatus">Initializing analysis...</h5>
                        <div class="progress mt-3" style="height: 25px; width: 300px; margin: 0 auto;">
                            <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated" 
                                 role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                                <span id="progressText">0%</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Results Section (hidden initially) -->
                <div id="analysisResults" style="display: none;">
                    <!-- Overall Sentiment -->
                    <div class="row mb-4">
                        <div class="col-md-12">
                            <div class="alert alert-info">
                                <h4 class="alert-heading"><i class="fas fa-chart-line"></i> Overall Sentiment</h4>
                                <p id="overallSentiment" class="mb-0"></p>
                            </div>
                        </div>
                    </div>
                    
                    
                    <!-- Charts Row -->
                    <div class="row mb-4">
                        <div class="col-md-12">
                            <div class="card">
<div class="card-header header-muted-blue">
                                    <h5 class="mb-0"><i class="fas fa-chart-pie"></i> Sentiment Distribution</h5>
                                </div>
                                <div class="card-body">
                                    <canvas id="sentimentPieChart" width="400" height="400"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- AI Summary -->
                    <div class="card mb-4">
<div class="card-header header-muted-blue">
                            <h5 class="mb-0"><i class="fas fa-robot"></i> AI Analysis Summary</h5>
                        </div>
                        <div class="card-body">
                            <div id="aiSummary" class="lead"></div>
                        </div>
                    </div>
                    
                    <!-- Sentiment Timeline -->
                    <div class="card mb-4">
                        <div class="card-header header-muted-blue">
                            <h5 class="mb-0"><i class="fas fa-clock"></i> Sentiment Timeline</h5>
                        </div>
                        <div class="card-body">
                            <canvas id="sentimentTimelineChart" width="400" height="200"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Sample Comments Section (Standalone, Wider) -->
        <div id="sampleCommentsSection" class="vibe-card mb-4 analysis-section" style="display: none;">
            <div class="card-header-vibe">
                <h3 class="mb-0">
                    <span class="emoji-icon">💬</span> Sample Comments by Sentiment
                </h3>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-lg-4">
                        <div class="sentiment-positive sentiment-header-section">
                            <h5>
                                <span><i class="fas fa-smile"></i> Positive</span>
                                <span class="badge" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;" id="positiveCount">0</span>
                            </h5>
                        </div>
                        <div id="positiveSamples" class="comment-samples-container"></div>
                    </div>
                    <div class="col-lg-4">
                        <div class="sentiment-neutral sentiment-header-section">
                            <h5>
                                <span><i class="fas fa-meh"></i> Neutral</span>
                                <span class="badge" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;" id="neutralCount">0</span>
                            </h5>
                        </div>
                        <div id="neutralSamples" class="comment-samples-container"></div>
                    </div>
                    <div class="col-lg-4">
                        <div class="sentiment-negative sentiment-header-section">
                            <h5>
                                <span><i class="fas fa-frown"></i> Negative</span>
                                <span class="badge" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;" id="negativeCount">0</span>
                            </h5>
                        </div>
                        <div id="negativeSamples" class="comment-samples-container"></div>
                    </div>
                </div>
                <!-- Feedback Notice -->
                <div class="feedback-notice mt-3">
                    <i class="fas fa-robot"></i>
                    Your feedback helps us improve our AI models. Click the sentiment buttons to correct any misclassifications.
                </div>
            </div>
        </div>
        
        {% else %}
        <!-- Error State -->
        <div class="card shadow">
            <div class="card-header bg-danger text-white">
                <h3 class="mb-0">
                    <i class="fas fa-exclamation-triangle"></i> Analysis Error
                </h3>
            </div>
            <div class="card-body">
                <div class="alert alert-danger">
                    <h5 class="alert-heading">Unable to analyze video</h5>
                    <p>{{ error }}</p>
                </div>
            </div>
        </div>
        {% endif %}
        
        <div class="text-center mt-4">
            <a href="{{ url_for('main.index') }}" class="vibe-button secondary">
                <span class="button-icon">⬅</span> Analyze Another Video
            </a>
        </div>
    </div>
</div>
</script>
{% endblock %}

{% block extra_js %}
<!-- Chart.js for visualization -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<!-- WordCloud2.js for word cloud visualization -->
<script src="https://cdn.jsdelivr.net/npm/wordcloud@1.2.2/src/wordcloud2.min.js"></script>

<script>
// Global variables
let analysisId = null;
let statusCheckInterval = null;
let charts = {};
let commentData = {
    positive: [],
    neutral: [],
    negative: []
};

// Define showToast function globally so it can be used by submitFeedback
function showToast(message, type = 'info', duration = 3000) {
    // Create toast container if it doesn't exist
    let toastContainer = document.getElementById('toastContainer');
    if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.id = 'toastContainer';
        toastContainer.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 9999;';
        document.body.appendChild(toastContainer);
    }
    
    // Create toast element
    const toast = document.createElement('div');
    toast.className = `alert alert-${type === 'success' ? 'success' : type === 'danger' ? 'danger' : type === 'warning' ? 'warning' : 'info'} alert-dismissible fade show`;
    toast.style.cssText = 'min-width: 250px; margin-bottom: 10px; animation: slideIn 0.3s ease-out;';
    toast.setAttribute('role', 'alert');
    
    // Add icon based on type
    const icon = type === 'success' ? '✓' : type === 'danger' ? '✕' : type === 'warning' ? '⚠' : 'ℹ';
    
    toast.innerHTML = `
        <strong>${icon}</strong> ${message}
        <button type="button" class="close" data-dismiss="alert" aria-label="Close">
            <span aria-hidden="true">&times;</span>
        </button>
    `;
    
    // Add toast to container
    toastContainer.appendChild(toast);
    
    // Auto-dismiss after duration
    setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
            toast.remove();
        }, 150);
    }, duration);
}

// Load user's previous feedback corrections
async function loadUserFeedback() {
    const videoId = '{{ video_id }}';
    
    try {
        // Fetch feedback from server
        const response = await fetch(`/api/sentiment-feedback?video_id=${videoId}`);
        const data = await response.json();
        
        if (data.success && data.feedback.length > 0) {
            // Store server feedback in localStorage for consistency
            const storageKey = `sentiment_corrections_${videoId}`;
            const corrections = {};
            
            data.feedback.forEach(fb => {
                const commentKey = fb.comment_text.substring(0, 100);
                corrections[commentKey] = {
                    original: fb.predicted_sentiment,
                    corrected: fb.corrected_sentiment,
                    timestamp: fb.created_at
                };
            });
            
            localStorage.setItem(storageKey, JSON.stringify(corrections));
            return corrections;
        }
    } catch (error) {
        console.error('Error loading user feedback:', error);
    }
    
    // Fall back to localStorage
    const storageKey = `sentiment_corrections_${videoId}`;
    return JSON.parse(localStorage.getItem(storageKey) || '{}');
}

// Apply stored corrections to displayed comments
function applyStoredCorrections() {
    const videoId = '{{ video_id }}';
    const storageKey = `sentiment_corrections_${videoId}`;
    const corrections = JSON.parse(localStorage.getItem(storageKey) || '{}');
    
    // Check each displayed comment for corrections
    Object.keys(commentData).forEach(sentiment => {
        commentData[sentiment].forEach((comment, index) => {
            const commentKey = comment.text.substring(0, 100);
            const correction = corrections[commentKey];
            
            if (correction) {
                // Find the comment element
                const commentId = `comment-${sentiment}-${index}`;
                const commentElement = document.getElementById(commentId);
                
                if (commentElement) {
                    // Apply the correction UI
                    applyManualCorrectionUI(commentElement, correction.original, correction.corrected);
                }
            }
        });
    });
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', async function() {
    // Load user's previous feedback first
    await loadUserFeedback();
    
    const startButton = document.getElementById('startSentimentAnalysis');
    const startButtonMain = document.getElementById('startSentimentAnalysisMain');
    
    // Check if comments are already loaded
    const fetchedComments = {{ comment_stats.fetched_comments }};
    const totalComments = {{ comment_stats.total_comments }};
    const isProUser = {{ (current_user.is_authenticated and current_user.is_subscribed)|tojson }};
    let isModified = false; // Track if user has modified the slider
    
    // If comments are already loaded, update UI
    if (fetchedComments > 0) {
        const loadedPercentage = Math.round((fetchedComments / totalComments) * 100);
        
        // Update button text to reflect loaded state
        if (startButtonMain) {
            startButtonMain.innerHTML = '<span class="button-icon">📊</span><span class="button-text">Load Analysis Results</span>';
        }
        
        // For Pro users, set slider to match loaded percentage
        const percentageSlider = document.getElementById('commentPercentageSlider');
        if (isProUser && percentageSlider) {
            percentageSlider.value = loadedPercentage;
            document.getElementById('percentageDisplay').textContent = loadedPercentage + '%';
            document.getElementById('commentCountEstimate').textContent = fetchedComments.toLocaleString();
            const estimatedTime = Math.max(1, Math.round((fetchedComments / 100) * 2 * 10) / 10);
            document.getElementById('timeEstimate').textContent = `~${estimatedTime}s`;
            
            // Update accuracy estimate
            const accuracyEl = document.getElementById('accuracyEstimate');
            if (accuracyEl) {
                if (loadedPercentage <= 30) {
                    accuracyEl.textContent = 'Quick';
                } else if (loadedPercentage <= 70) {
                    accuracyEl.textContent = 'Good';
                } else {
                    accuracyEl.textContent = 'Best';
                }
            }
            
            // Update tip
            const tipEl = document.getElementById('coverageTip');
            if (tipEl) {
                tipEl.textContent = `${fetchedComments} comments already loaded - click to analyze`;
            }
        }
    }
    
    if (startButton) {
        startButton.addEventListener('click', startSentimentAnalysis);
    }
    if (startButtonMain) {
        startButtonMain.addEventListener('click', startSentimentAnalysis);
    }
    
    // Percentage slider event listener for Pro users
    const percentageSlider = document.getElementById('commentPercentageSlider');
    if (percentageSlider) {
        percentageSlider.addEventListener('input', function() {
            // Mark as modified when user changes the slider
            isModified = true;
            
            // If slider was modified and comments were preloaded, change button back
            if (fetchedComments > 0 && startButtonMain) {
                const selectedPercentage = parseInt(this.value);
                const selectedComments = Math.ceil(totalComments * (selectedPercentage / 100));
                
                // If the selected value differs from what's loaded, change button text
                if (Math.abs(selectedComments - fetchedComments) > 5) { // Allow small margin
                    startButtonMain.innerHTML = '<span class="button-icon">🧠</span><span class="button-text">Analyze Sentiment</span>';
                } else {
                    // If slider is back to loaded amount, show "Load Results"
                    startButtonMain.innerHTML = '<span class="button-icon">📊</span><span class="button-text">Load Analysis Results</span>';
                }
            }
            const percentage = this.value;
            const commentCount = Math.ceil(totalComments * (percentage / 100));
            const estimatedTime = Math.max(1, Math.round((commentCount / 100) * 2 * 10) / 10); // Estimate ~2 seconds per 100 comments
            
            // Update displays
            document.getElementById('percentageDisplay').textContent = percentage + '%';
            document.getElementById('commentCountEstimate').textContent = commentCount.toLocaleString();
            document.getElementById('timeEstimate').textContent = `~${estimatedTime}s`;
            
            // Update accuracy estimate
            const accuracyEl = document.getElementById('accuracyEstimate');
            if (accuracyEl) {
                if (percentage <= 30) {
                    accuracyEl.textContent = 'Quick';
                } else if (percentage <= 70) {
                    accuracyEl.textContent = 'Good';
                } else {
                    accuracyEl.textContent = 'Best';
                }
            }
            
            // Update tip
            const tipEl = document.getElementById('coverageTip');
            if (tipEl) {
                if (percentage <= 30) {
                    tipEl.textContent = 'Quick analysis - good for a rapid overview';
                } else if (percentage <= 70) {
                    tipEl.textContent = 'Balanced analysis - recommended for most use cases';
                } else {
                    tipEl.textContent = 'Comprehensive analysis - best accuracy';
                }
            }
        });
    }
    
});


function formatEnhancedSummary(insights) {
    // Convert the detailed insights into well-formatted HTML
    if (!insights) return '';
    
    // Split by sections and format each
    const lines = insights.split('\n');
    let html = '';
    let inSection = false;
    let inThemeSection = false;
    
    lines.forEach(line => {
        // Skip empty lines
        if (!line.trim()) {
            if (inSection) {
                html += '</div>';
                inSection = false;
            }
            return;
        }
        
        // Format main section headers with emojis
        if (line.includes('📊 SENTIMENT LANDSCAPE:')) {
            if (inSection) html += '</div>';
            const content = line.replace('📊 SENTIMENT LANDSCAPE:', '').trim();
            html += `
                <div class="alert alert-info mb-3">
                    <h6 class="alert-heading"><i class="fas fa-chart-pie"></i> Sentiment Landscape</h6>
                    <p class="mb-0">${content}</p>
            `;
            inSection = true;
        }
        else if (line.includes('🎯 KEY DISCUSSION THEMES:')) {
            // Skip rendering this section here; themes are rendered by the dedicated component
            if (inSection) {
                html += '</div>';
                inSection = false;
            }
            inThemeSection = false;
            // Do not output anything for this section
        }
        // Skip sub-items (remove text without headers)
        else if (line.trim().startsWith('-')) {
            // intentionally omitted
        }
        // Format numbered items (themes)
        else if (inThemeSection && line.match(/^\s+\d+\./)) {
            const content = line.trim();
            const parts = content.match(/^(\d+)\. '([^']+)' - (.+) \(score: ([\d.]+)\)/);
            if (parts) {
                const [, num, theme, relevance, score] = parts;
                // Skip "Emerging topic" - only show High and Moderate relevance
                if (!relevance.includes('Emerging')) {
                    const isHigh = relevance.includes('High');
                    const badgeClass = isHigh ? 'badge-danger' : 'badge-warning';
                    const iconClass = isHigh ? 'fas fa-fire' : 'fas fa-star';
                    const themeClass = isHigh ? 'theme-item-high' : 'theme-item-moderate';
                    // Start row div if needed
                    if (!html.includes('theme-grid')) {
                        html += '<div class="row theme-grid">';
                    }
                    html += `
                        <div class="col-md-6 mb-3">
                            <div class="theme-item ${themeClass}">
                                <div class="d-flex align-items-center">
                                    <span class="badge ${badgeClass}">
                                        <i class="${iconClass} mr-1"></i>${num}
                                    </span>
                                    <strong>${theme}</strong>
                                </div>
                            </div>
                        </div>
                    `;
                }
            } else {
                html += `<div class="ml-3">${content}</div>`;
            }
        }
        // Skip regular text lines without headers between sections
        else if (line.trim()) {
            // intentionally omitted
        }
    });
    
    // Close any open sections
    if (inSection) {
        // Close theme grid if open
        if (inThemeSection && html.includes('theme-grid')) {
            html += '</div>'; // Close row
            html += '</div>'; // Close theme-content
        }
        if (html.includes('<ul') && !html.endsWith('</ul>')) {
            html += '</ul>';
        }
        if (!inThemeSection) {
            html += '</div>'; // Close alert or other containers
        }
        if (html.includes('card-body')) {
            html += '</div></div>'; // Close card-body and card
        }
    }
    
    return html;
}


function updateCommentStatistics(stats) {
    // Only update if we have stats and Pro users analyzed more than originally fetched
    const isProUser = {{ (current_user.is_authenticated and current_user.is_subscribed)|tojson }};
    if (!stats || !isProUser) return;
    
    // Add a visual indicator that stats have been updated
    const commentAnalysisHeaders = document.querySelectorAll('.card-header-vibe h3');
    const commentAnalysisHeader = commentAnalysisHeaders[1]; // Second header is Comment Analysis
    if (commentAnalysisHeader && !commentAnalysisHeader.querySelector('.updated-badge')) {
        const badge = document.createElement('span');
        badge.className = 'badge badge-success ml-2 updated-badge';
        badge.textContent = 'Updated';
        badge.style.fontSize = '0.6em';
        badge.style.verticalAlign = 'middle';
        badge.style.animation = 'fadeIn 0.5s';
        commentAnalysisHeader.appendChild(badge);
    }
    
    // Update the alert with analyzed count
    const alertInfo = document.querySelector('.alert-info');
    if (alertInfo && stats.total_analyzed) {
        const newAlertContent = `
            <i class="fas fa-info-circle"></i> 
            <strong>Analysis Updated:</strong> Analyzed <strong>${stats.total_analyzed}</strong> comments 
            (<strong>${stats.analysis_depth_percentage}%</strong> of total available)
            <br>
            <small class="text-muted">
                <i class="fas fa-chart-line"></i> Statistics below reflect the expanded analysis dataset
            </small>
        `;
        alertInfo.innerHTML = newAlertContent;
        alertInfo.classList.add('alert-success');
        alertInfo.classList.remove('alert-info');
    }
    
    // Update individual stat cards with animation
    const updateStatCard = (selector, value, isFormattedNumber = false) => {
        const element = document.querySelector(selector);
        if (element) {
            const oldValue = element.textContent;
            if (isFormattedNumber) {
                element.textContent = value.toLocaleString();
            } else {
                element.textContent = value;
            }
            // Add highlight effect if value changed
            if (oldValue !== element.textContent) {
                element.style.animation = 'pulse 1s';
                element.style.color = '#10b981';
                setTimeout(() => {
                    element.style.animation = '';
                    element.style.color = '';
                }, 1000);
            }
        }
    };
    
    // Update each statistic - target specific comment stats cards (skip video stats)
    const commentStatsSection = document.querySelectorAll('.vibe-card')[1]; // Second vibe-card is Comment Analysis
    if (commentStatsSection) {
        const statsCards = commentStatsSection.querySelectorAll('.stats-card');
        if (statsCards.length >= 4) {
            updateStatCard('.vibe-card:nth-of-type(2) .row:nth-of-type(2) .col-md-6:nth-child(1) .stats-value', stats.unique_commenters, true);
            updateStatCard('.vibe-card:nth-of-type(2) .row:nth-of-type(2) .col-md-6:nth-child(2) .stats-value', stats.avg_comment_length);
            updateStatCard('.vibe-card:nth-of-type(2) .row:nth-of-type(2) .col-md-6:nth-child(3) .stats-value', stats.top_level_count, true);
            updateStatCard('.vibe-card:nth-of-type(2) .row:nth-of-type(2) .col-md-6:nth-child(4) .stats-value', stats.replies_count, true);
        }
    }
    
    // Update top commenters if present
    if (stats.top_commenters && stats.top_commenters.length > 0) {
        const topCommentersContainer = document.querySelector('.list-group-flush');
        if (topCommentersContainer) {
            topCommentersContainer.innerHTML = '';
            stats.top_commenters.forEach((commenter, index) => {
                const li = document.createElement('li');
                li.className = 'list-group-item d-flex justify-content-between align-items-center';
                li.innerHTML = `
                    <span><strong>#${index + 1}</strong> ${commenter[0]}</span>
                    <span class="badge badge-primary badge-pill">${commenter[1]} comments</span>
                `;
                topCommentersContainer.appendChild(li);
            });
        }
    }
}

function startSentimentAnalysis() {
    const videoId = '{{ video_id }}';
    const section = document.getElementById('sentimentAnalysisSection');
    const progressDiv = document.getElementById('analysisProgress');
    const resultsDiv = document.getElementById('analysisResults');
    const startButton = document.getElementById('startSentimentAnalysis');
    const startButtonMain = document.getElementById('startSentimentAnalysisMain');
    
    // Get the selected percentage - 10% for free users, slider value for pro users
    const isProUser = {{ (current_user.is_authenticated and current_user.is_subscribed)|tojson }};
    const percentageSlider = document.getElementById('commentPercentageSlider');
    const selectedPercentage = isProUser && percentageSlider ? parseInt(percentageSlider.value) : 10;
    const totalComments = {{ comment_stats.total_comments }};
    const fetchedComments = {{ comment_stats.fetched_comments }};
    const maxFreeComments = 100; // Cap free analysis at 100 comments
    const commentsToAnalyze = isProUser ? 
        Math.ceil(totalComments * (selectedPercentage / 100)) : 
        Math.min(Math.ceil(totalComments * 0.1), maxFreeComments);
    
    // Check if we can use already loaded comments
    const usePreloaded = fetchedComments > 0 && 
                         Math.abs(commentsToAnalyze - fetchedComments) <= 5; // Allow small margin
    
    // Show section and hide results
    section.style.display = 'block';
    section.classList.add('active');
    progressDiv.style.display = 'flex';
    resultsDiv.style.display = 'none';
    
    // Disable both buttons with appropriate text
    const loadingText = usePreloaded ? 'Loading Cached Results...' : 'Analyzing...';
    if (startButton) {
        startButton.disabled = true;
        startButton.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${loadingText}`;
    }
    if (startButtonMain) {
        startButtonMain.disabled = true;
        startButtonMain.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${loadingText}`;
    }
    
    // Scroll to sentiment analysis section
    section.scrollIntoView({ behavior: 'smooth', block: 'start' });
    
    // If we have preloaded comments and button says "Load Analysis Results", check for cached results first
    if (usePreloaded && startButtonMain && startButtonMain.textContent.includes('Load Analysis')) {
        // Generate the expected analysis ID for cached results
        const expectedAnalysisId = `sentiment_${videoId}_${selectedPercentage}pct_${commentsToAnalyze}`;
        
        // Try to fetch cached results directly
        fetch(`/api/analyze/results/${expectedAnalysisId}`)
            .then(response => {
                // Check status code to determine what happened
                if (response.status === 202) {
                    // Analysis exists but not yet completed - wait for it
                    return response.json().then(data => {
                        console.log('Analysis in progress, waiting for completion...');
                        analysisId = expectedAnalysisId;
                        // Update progress status  
                        if (data.status) {
                            updateProgress(data.status);
                        }
                        // Start polling for completion
                        statusCheckInterval = setInterval(checkAnalysisStatus, 1000);
                        return null; // Signal that we're waiting
                    });
                } else if (response.ok) {
                    return response.json();
                } else {
                    // Handle error responses
                    return response.json().then(data => {
                        throw new Error(data.error || 'Failed to fetch results');
                    });
                }
            })
            .then(data => {
                if (data === null) {
                    // We're waiting for in-progress analysis
                    return;
                }
                if (data && data.success && data.results) {
                    // Cached results found! Display them immediately
                    analysisId = expectedAnalysisId;
                    displayResults(data.results);
                    return; // Exit early, no need to start new analysis
                } else {
                    // No cached results, proceed with analysis
                    initiateAnalysis(videoId, commentsToAnalyze, selectedPercentage);
                }
            })
            .catch(error => {
                // Error fetching cached results, proceed with analysis
                console.log('No cached results available, starting analysis:', error.message);
                initiateAnalysis(videoId, commentsToAnalyze, selectedPercentage);
            });
    } else {
        // Not using preloaded or different comment count, start fresh analysis
        initiateAnalysis(videoId, commentsToAnalyze, selectedPercentage);
    }
}

function initiateAnalysis(videoId, commentsToAnalyze, selectedPercentage) {
    // Start analysis with selected number of comments
    fetch(`/api/analyze/sentiment/${videoId}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            max_comments: commentsToAnalyze,  // Use calculated count based on percentage
            percentage_selected: selectedPercentage  // Send percentage for logging
        })
    })
    .then(response => {
        if (response.status === 507) {
            // Insufficient Storage - cache memory full
            showError('The analysis cache is currently full. Please wait a moment while we clear some space and try again.');
            // Automatically retry after 3 seconds
            setTimeout(() => {
                showError('Retrying analysis...');
                startSentimentAnalysis();
            }, 3000);
            return null;
        }
        return response.json();
    })
    .then(data => {
        if (data === null) return; // Handled above
        
        if (data.success) {
            analysisId = data.analysis_id;
            if (data.cached) {
                // If cached, fetch results immediately
                fetchAnalysisResults();
            } else {
                // Start polling for status
                statusCheckInterval = setInterval(checkAnalysisStatus, 1000);
            }
        } else {
            if (data.error && data.error.includes('memory')) {
                showError('Cache memory issue detected. Clearing space and retrying...');
                setTimeout(() => startSentimentAnalysis(), 2000);
            } else {
                showError(data.error);
            }
        }
    })
    .catch(error => {
        showError('Failed to start analysis: ' + error);
    });
}

function checkAnalysisStatus() {
    if (!analysisId) return;
    
    fetch(`/api/analyze/status/${analysisId}`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                updateProgress(data.status);
                
                if (data.status.status === 'completed') {
                    clearInterval(statusCheckInterval);
                    fetchAnalysisResults();
                } else if (data.status.status === 'error') {
                    clearInterval(statusCheckInterval);
                    showError(data.status.error);
                }
            } else if (!data.success && data.error === 'Analysis not found') {
                // Analysis was lost, restart automatically
                clearInterval(statusCheckInterval);
                console.log('Analysis not found during status check, restarting...');
                showError('Analysis data was cleared. Restarting...');
                analysisId = null;
                setTimeout(() => {
                    startSentimentAnalysis();
                }, 1500);
            }
        })
        .catch(error => {
            console.error('Status check error:', error);
        });
}

function updateProgress(status) {
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const progressStatus = document.getElementById('progressStatus');
    
    const progress = status.progress || 0;
    progressBar.style.width = progress + '%';
    progressBar.setAttribute('aria-valuenow', progress);
    progressText.textContent = progress + '%';
    
    // Update status text
    let statusText = 'Processing...';
    switch(status.status) {
        case 'fetching_comments':
            statusText = '🎬 Fetching additional comments from YouTube for analysis...';
            break;
        case 'using_cached':
            statusText = '📊 Using preloaded comments for analysis...';
            break;
        case 'analyzing_sentiment':
            statusText = `🧠 Analyzing comment contents... (${status.current || 0}/${status.total || 0} comments)`;
            break;
        case 'generating_summary':
            statusText = '🤖 Our AI is generating results...';
            break;
        case 'completed':
            statusText = '✨ Analysis complete!';
            break;
    }
    progressStatus.textContent = statusText;
}

function fetchAnalysisResults() {
    if (!analysisId) return;
    
    fetch(`/api/analyze/results/${analysisId}`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                displayResults(data.results);
            } else {
                if (data.restart_needed) {
                    // Results are missing, restart the analysis
                    console.error('Results missing, restarting analysis...');
                    showError('Previous analysis expired. Starting fresh analysis...');
                    // Clear the current analysis ID and restart
                    analysisId = null;
                    setTimeout(() => {
                        startSentimentAnalysis();
                    }, 2000);
                } else if (data.error && data.error.includes('Analysis not found')) {
                    // Analysis was cleared or expired
                    showError('This analysis has expired or been cleared. Starting a new analysis...');
                    analysisId = null;
                    // Automatically restart the analysis
                    setTimeout(() => {
                        // Reset UI
                        const progressDiv = document.getElementById('analysisProgress');
                        const resultsDiv = document.getElementById('analysisResults');
                        if (progressDiv) progressDiv.style.display = 'flex';
                        if (resultsDiv) resultsDiv.style.display = 'none';
                        // Start fresh analysis
                        startSentimentAnalysis();
                    }, 1500);
                } else {
                    showError(data.error + (data.details ? ': ' + data.details : ''));
                }
            }
        })
        .catch(error => {
            showError('Failed to fetch results: ' + error);
        });
}

function displayResults(results) {
    console.log('displayResults called with:', results);
    const progressDiv = document.getElementById('analysisProgress');
    const resultsDiv = document.getElementById('analysisResults');
    const samplesSection = document.getElementById('sampleCommentsSection');
    const startButton = document.getElementById('startSentimentAnalysis');
    const startButtonMain = document.getElementById('startSentimentAnalysisMain');
    const videoId = '{{ video_id }}';
    
    // Update comment statistics if Pro user analyzed more comments
    if (results.updated_stats) {
        updateCommentStatistics(results.updated_stats);
    }
    
    // Hide progress, show results
    progressDiv.style.display = 'none';
    resultsDiv.style.display = 'block';
    
    // Show sample comments section
    if (samplesSection) {
        samplesSection.style.display = 'block';
    }
    
    // Re-enable both buttons
    if (startButton) {
        startButton.innerHTML = '<i class="fas fa-sync"></i> Re-analyze';
        startButton.disabled = false;
    }
    if (startButtonMain) {
        startButtonMain.innerHTML = '<i class="fas fa-sync"></i> Re-analyze';
        startButtonMain.disabled = false;
    }
    
    // Get sentiment data
    const sentiment = results.sentiment;
    
    // Overall sentiment
    const overallEl = document.getElementById('overallSentiment');
    // Convert score to percentage if it's not already
    const sentimentScorePercent = sentiment.sentiment_score > 1 ? 
        sentiment.sentiment_score.toFixed(1) : 
        (sentiment.sentiment_score * 100).toFixed(1);
    overallEl.innerHTML = `
        <strong>${sentiment.overall_sentiment}</strong> 
        (Score: ${sentimentScorePercent}%, 
        Confidence: ${(sentiment.average_confidence * 100).toFixed(1)}%)
        <br>
        <small>Analyzed ${sentiment.total_analyzed} comments using advanced sentiment analysis</small>
    `;
    
    // AI Summary with Enhanced Details
    const summary = results.summary;
    const aiSummaryEl = document.getElementById('aiSummary');
    
    // Format the enhanced summary for better readability
    if (summary.detailed_insights) {
        const insights = summary.detailed_insights;
        
        // Check for any reception type sections
        const receptionTypes = [
            { marker: '⚡ CONTROVERSY DETECTED:', type: 'controversy', icon: 'fas fa-bolt', alertClass: 'alert-warning' },
            { marker: '🎆 OVERWHELMINGLY POSITIVE RECEPTION:', type: 'positive', icon: 'fas fa-star', alertClass: 'alert-success' },
            { marker: '✅ POSITIVE RECEPTION:', type: 'positive', icon: 'fas fa-check-circle', alertClass: 'alert-success' },
            { marker: '🤔 MIXED RECEPTION:', type: 'mixed', icon: 'fas fa-balance-scale', alertClass: 'alert-info' },
            { marker: '⚠️ CRITICAL RECEPTION:', type: 'critical', icon: 'fas fa-exclamation-triangle', alertClass: 'alert-danger' }
        ];
        
        let mainInsights = insights;
        let receptionContent = null;
        let receptionType = null;
        
        // Find which reception type is in the insights
        for (const reception of receptionTypes) {
            const index = insights.indexOf(reception.marker);
            if (index > -1) {
                mainInsights = insights.substring(0, index).trim();
                const receptionSection = insights.substring(index);
                receptionType = reception;
                
                // Extract reception details
                const lines = receptionSection.split('\n');
                let receptionHtml = '';
                for (let i = 1; i < lines.length && i < 5; i++) {
                    if (lines[i].trim()) {
                        receptionHtml += `<p class="mb-2">${lines[i].trim()}</p>`;
                    }
                }
                
                // Add controversial topics with enhanced details if it's controversy type
                if (reception.type === 'controversy' && summary.controversy_analysis && 
                    summary.controversy_analysis.topics && summary.controversy_analysis.topics.length > 0) {
                    
                    // Get up to 6 controversial comments with sentiment data
                    const controversialComments = summary.controversy_analysis.topics
                        .filter(topic => topic.comment_id)
                        .slice(0, 6);
                    
                    if (controversialComments.length > 0) {
                        receptionHtml += '<div class="mt-4"><strong>Examples of divisive comments:</strong></div>';
                        controversialComments.forEach((topic, idx) => {
                            // Get sentiment data for this comment if available
                            const sentimentData = sentiment.individual_results ? 
                                sentiment.individual_results.find(r => 
                                    (r.comment_id === topic.comment_id) || 
                                    (r.text && r.text.substring(0, 50) === topic.text.substring(0, 50))
                                ) : null;
                            
                            const aiSentiment = sentimentData ? 
                                (sentimentData.predicted_sentiment || sentimentData.sentiment || 'unknown') : 
                                'unknown';
                            
                            const confidence = sentimentData && sentimentData.confidence ? 
                                (sentimentData.confidence * 100).toFixed(0) : 'N/A';
                            
                            // Determine sentiment emoji and color
                            let sentimentEmoji = '🤷';
                            let sentimentColor = 'secondary';
                            let sentimentLabel = 'Unknown';
                            
                            if (aiSentiment === 'positive') {
                                sentimentEmoji = '😊';
                                sentimentColor = 'success';
                                sentimentLabel = 'Positive';
                            } else if (aiSentiment === 'negative') {
                                sentimentEmoji = '😔';
                                sentimentColor = 'danger';
                                sentimentLabel = 'Negative';
                            } else if (aiSentiment === 'neutral') {
                                sentimentEmoji = '😐';
                                sentimentColor = 'secondary';
                                sentimentLabel = 'Neutral';
                            }
                            
                            const commentSnippet = topic.text.length > 200 ? 
                                topic.text.substring(0, 200) + '...' : topic.text;
                            
                            // Determine why it's controversial
                            let controversyReason = '';
                            if (topic.controversy_score && topic.controversy_score > 0.7) {
                                controversyReason = 'This comment has highly polarized reactions.';
                            } else if (aiSentiment === 'positive' && topic.text.toLowerCase().includes('but')) {
                                controversyReason = 'Mixed signals: Contains both praise and criticism.';
                            } else if (aiSentiment === 'negative') {
                                controversyReason = 'Critical viewpoint that sparked debate.';
                            } else if (aiSentiment === 'neutral') {
                                controversyReason = 'Balanced perspective that divided opinions.';
                            } else {
                                controversyReason = 'This comment generated significant discussion.';
                            }
                            
                            // Set colors based on sentiment
                            let badgeStyle = '';
                            if (aiSentiment === 'positive') {
                                badgeStyle = 'background: #28a745; color: white;';
                            } else if (aiSentiment === 'negative') {
                                badgeStyle = 'background: #dc3545; color: white;';
                            } else if (aiSentiment === 'neutral') {
                                badgeStyle = 'background: #6c757d; color: white;';
                            } else {
                                badgeStyle = 'background: #6c757d; color: white;';
                            }
                            
                            receptionHtml += `
                                <div class="mt-3 p-3 border rounded" style="background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-left: 4px solid var(--bs-${sentimentColor}) !important;">
                                    <div class="d-flex justify-content-between align-items-start mb-2">
                                        <span class="badge" style="${badgeStyle}">
                                            ${sentimentEmoji} AI: ${sentimentLabel} (${confidence}% confident)
                                        </span>
                                        <small class="text-muted">#${idx + 1}</small>
                                    </div>
                                    <p class="mb-2" style="font-style: italic; color: #495057;">
                                        "${commentSnippet}"
                                    </p>
                                    <div class="alert alert-sm alert-info py-1 px-2 mb-0" style="font-size: 0.85rem;">
                                        <i class="fas fa-info-circle"></i> <strong>Why controversial:</strong> ${controversyReason}
                                    </div>
                                    ${topic.replies_count ? `
                                        <small class="text-muted mt-2 d-block">
                                            <i class="fas fa-comments"></i> Generated ${topic.replies_count} replies
                                        </small>
                                    ` : ''}
                                </div>
                            `;
                        });
                    }
                }
                
                if (receptionHtml) {
                    // Create reception alert box with appropriate styling
                    const heading = reception.marker.replace(/[:]/g, '').replace(/[\u{1F300}-\u{1F9FF}]/gu, '').trim();
                    receptionContent = `
                        <div class="alert ${reception.alertClass} mb-4">
                            <h5 class="alert-heading"><i class="${reception.icon}"></i> ${heading}</h5>
                            ${receptionHtml}
                        </div>
                    `;
                }
                break;
            }
        }
        
        // Display main insights
        aiSummaryEl.innerHTML = formatEnhancedSummary(mainInsights);

        // Append Most Mentioned Concepts box (green) using available data
        const conceptsHTML = buildMostMentionedConceptsHTML(summary);
        if (conceptsHTML) {
            aiSummaryEl.innerHTML += conceptsHTML;
        }
        
        // Add reception box after main summary if it exists
        if (receptionContent) {
            aiSummaryEl.innerHTML += receptionContent;
        }
    } else {
        // Fallback to plain summary
        aiSummaryEl.textContent = summary.summary;
    }
    
    // Create charts (with small delay to ensure elements are visible)
    setTimeout(() => {
        createSentimentPieChart(sentiment);
        createTimelineChart(results.timeline);
    }, 100);
    
    // Display sample comments
    displaySampleComments(sentiment.individual_results);
}

function createSentimentPieChart(sentiment) {
    try {
        const ctx = document.getElementById('sentimentPieChart').getContext('2d');
        
        if (charts.pie) charts.pie.destroy();
        
        charts.pie = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: ['Positive', 'Neutral', 'Negative'],
                datasets: [{
                    data: [
                        sentiment.sentiment_counts.positive,
                        sentiment.sentiment_counts.neutral,
                        sentiment.sentiment_counts.negative
                    ],
                    backgroundColor: [
                        // Positive: match the green background used by Most Mentioned Concepts (Bootstrap alert-success bg)
                        'rgba(209, 231, 221, 0.9)',
                        // Neutral: lighter gray
                        'rgba(206, 212, 218, 0.9)',
                        // Negative: complementary red to the green above
                        'rgba(227, 93, 106, 0.85)'
                    ],
                    borderColor: [
                        // Positive border: Bootstrap success
                        'rgba(25, 135, 84, 1)',
                        'rgba(160, 165, 170, 1)',
                        // Negative border: deeper complementary red
                        'rgba(176, 42, 55, 1)'
                    ],
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom',
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.parsed || 0;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(1);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    } catch (error) {
        console.error('Error creating pie chart:', error);
    }
}

function buildMostMentionedConceptsHTML(summary) {
    try {
        if (!summary) return '';

        // Prefer social_media_themes if available
        let items = [];
        if (summary.social_media_themes && Array.isArray(summary.social_media_themes.themes)) {
            items = summary.social_media_themes.themes.map(t => ({
                word: t.word || t.term || t.key || '',
                percent: typeof t.percentage === 'number' ? t.percentage : (typeof t.score === 'number' ? t.score * 100 : 0)
            }));
        } else if (Array.isArray(summary.intelligent_themes)) {
            // intelligent_themes is typically [ [word, score], ... ]
            items = summary.intelligent_themes.map(t => ({
                word: Array.isArray(t) ? t[0] : (t.word || t || ''),
                percent: Array.isArray(t) && typeof t[1] === 'number' ? t[1] * 100 : (typeof t.score === 'number' ? t.score * 100 : 0)
            }));
        }

        // Clean and sort
        items = items
            .filter(i => i.word && typeof i.percent === 'number')
            .sort((a, b) => b.percent - a.percent)
            .slice(0, 10);

        if (items.length === 0) return '';

        // Build green alert styled like Sentiment Landscape
        let html = '';
        html += '<div class="alert alert-success mb-3">';
        html += '<h6 class="alert-heading"><i class="fas fa-tags"></i> Most Mentioned Concepts</h6>';
        html += '<ul class="mb-0">';
        items.forEach((it, idx) => {
            const pct = Math.round(it.percent);
            html += `<li class="small">${idx + 1}. <strong>${it.word}</strong> — ${pct}%</li>`;
        });
        html += '</ul>';
        html += '</div>';
        return html;
    } catch (e) {
        console.error('Error building Most Mentioned Concepts:', e);
        return '';
    }
}

function createTimelineChart(timeline) {
    try {
        const ctx = document.getElementById('sentimentTimelineChart').getContext('2d');
        
        if (charts.timeline) charts.timeline.destroy();
        
        if (!timeline || timeline.length === 0) return;
        
        // Process timeline data with more meaningful labels
        const labels = [];
        const positiveData = [];
        const neutralData = [];
        const negativeData = [];
        
        const sampleSize = Math.min(timeline.length, 30);
        const groupSize = Math.ceil(sampleSize / 10); // Create ~10 groups
        
        timeline.slice(0, sampleSize).forEach((item, index) => {
            // Create time-based or grouped labels
            if (index === 0) {
                labels.push('Early');
            } else if (index === Math.floor(sampleSize / 4)) {
                labels.push('25%');
            } else if (index === Math.floor(sampleSize / 2)) {
                labels.push('Midpoint');
            } else if (index === Math.floor(sampleSize * 3 / 4)) {
                labels.push('75%');
            } else if (index === sampleSize - 1) {
                labels.push('Recent');
            } else if (index % groupSize === 0) {
                labels.push(`${Math.round((index / sampleSize) * 100)}%`);
            } else {
                labels.push(''); // Empty label for intermediate points
            }
            
            positiveData.push(item.score.positive * 100);
            neutralData.push(item.score.neutral * 100);
            negativeData.push(item.score.negative * 100);
        });
        
        charts.timeline = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    {
label: 'Positive',
                        data: positiveData,
                        borderColor: 'rgba(25, 135, 84, 1)',
                        backgroundColor: 'rgba(209, 231, 221, 0.35)',
                        tension: 0.4
                    },
                    {
label: 'Neutral',
                        data: neutralData,
                        borderColor: 'rgba(160, 165, 170, 1)',
                        backgroundColor: 'rgba(206, 212, 218, 0.35)',
                        tension: 0.4
                    },
                    {
label: 'Negative',
                        data: negativeData,
                        borderColor: 'rgba(176, 42, 55, 1)',
                        backgroundColor: 'rgba(227, 93, 106, 0.25)',
                        tension: 0.4
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Comment Timeline (Early → Recent)',
                            font: {
                                size: 12
                            }
                        },
                        ticks: {
                            autoSkip: false,
                            maxRotation: 0,
                            font: {
                                size: 11
                            }
                        }
                    },
                    y: {
                        beginAtZero: true,
                        max: 100,
                        title: {
                            display: true,
                            text: 'Sentiment Score',
                            font: {
                                size: 12
                            }
                        },
                        ticks: {
                            callback: function(value) {
                                return value + '%';
                            }
                        }
                    }
                },
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    legend: {
                        position: 'bottom',
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            title: function(tooltipItems) {
                                const index = tooltipItems[0].dataIndex;
                                const total = tooltipItems[0].chart.data.labels.length;
                                const position = tooltipItems[0].label || `Position ${index + 1}/${total}`;
                                return `Timeline: ${position}`;
                            },
                            label: function(context) {
                                const label = context.dataset.label;
                                const value = context.parsed.y.toFixed(1);
                                const emoji = label === 'Positive' ? '😊' : label === 'Negative' ? '😔' : '😐';
                                return `${emoji} ${label}: ${value}%`;
                            },
                            afterLabel: function(context) {
                                // Show dominant sentiment at this point
                                if (context.datasetIndex === 0) { // Only show once
                                    const datasets = context.chart.data.datasets;
                                    const index = context.dataIndex;
                                    const positive = datasets[0].data[index];
                                    const neutral = datasets[1].data[index];
                                    const negative = datasets[2].data[index];
                                    
                                    let dominant = 'Neutral';
                                    if (positive > neutral && positive > negative) dominant = 'Positive';
                                    else if (negative > neutral && negative > positive) dominant = 'Negative';
                                    
                                    return `\nDominant: ${dominant}`;
                                }
                            }
                        }
                    }
                }
            }
        });
    } catch (error) {
        console.error('Error creating timeline chart:', error);
    }
}


function displaySampleComments(results) {
    try {
        if (!results || !Array.isArray(results)) {
            console.error('Invalid results data for sample comments:', results);
            return;
        }
        
        const videoId = '{{ video_id }}';
        const positive = [];
        const neutral = [];
        const negative = [];
        
        // Categorize ALL comments (not just 3)
        results.forEach(result => {
            const comment = {
                text: result.text,
                confidence: (result.confidence * 100).toFixed(1),
                commentId: result.comment_id || null,
                author: result.author || 'Anonymous'
            };
            
            // Check for both 'predicted_sentiment' and 'sentiment' fields for compatibility
            const sentiment = result.predicted_sentiment || result.sentiment;
            
            if (sentiment === 'positive') {
                positive.push(comment);
            } else if (sentiment === 'neutral') {
                neutral.push(comment);
            } else if (sentiment === 'negative') {
                negative.push(comment);
            }
        });
        
        // Sort by confidence (highest first)
        positive.sort((a, b) => parseFloat(b.confidence) - parseFloat(a.confidence));
        neutral.sort((a, b) => parseFloat(b.confidence) - parseFloat(a.confidence));
        negative.sort((a, b) => parseFloat(b.confidence) - parseFloat(a.confidence));
        
        // Update counts
        document.getElementById('positiveCount').textContent = positive.length;
        document.getElementById('neutralCount').textContent = neutral.length;
        document.getElementById('negativeCount').textContent = negative.length;
        
        // Display samples with enhanced formatting
        const displaySamples = (samples, elementId, sentimentClass) => {
            const el = document.getElementById(elementId);
            if (samples.length === 0) {
                el.innerHTML = '<p class="text-muted text-center py-3">No samples available</p>';
            } else {
                // Show up to 50 comments per category for better overview
                const displayLimit = Math.min(samples.length, 50);
                const truncateText = (text, maxLength = 300) => {
                    if (text.length <= maxLength) return text;
                    return text.substring(0, maxLength) + '...';
                };
                
                el.innerHTML = samples.slice(0, displayLimit).map((s, index) => {
                    const truncated = truncateText(s.text);
                    const confidenceColor = parseFloat(s.confidence) >= 80 ? 'success' : 
                                           parseFloat(s.confidence) >= 60 ? 'warning' : 'secondary';
                    const commentId = `comment-${sentimentClass}-${index}`;
                    
                    return `
                        <div class="comment-sample-item ${sentimentClass}" id="${commentId}" data-comment-index="${index}">
                            <div class="comment-sample-text">
                                ${escapeHtml(truncated)}
                            </div>
                            <div class="comment-sample-meta">
                                <span class="text-muted">
                                    <i class="fas fa-user-circle"></i> ${escapeHtml(s.author.substring(0, 20))}
                                </span>
                                <span class="confidence-badge bg-${confidenceColor}">
                                    ${s.confidence}%
                                </span>
                            </div>
                            <div class="feedback-buttons">
                                <span class="text-muted" style="font-size: 0.7rem; margin-right: 8px;">AI thinks:</span>
                                <button class="feedback-btn positive ${sentimentClass === 'positive' ? 'current-sentiment' : ''}" 
                                        ${sentimentClass === 'positive' ? 'disabled' : ''}
                                        onclick="submitFeedback('${commentId}', '${sentimentClass}', 'positive', ${index})">
                                    👍 Positive
                                </button>
                                <button class="feedback-btn neutral ${sentimentClass === 'neutral' ? 'current-sentiment' : ''}" 
                                        ${sentimentClass === 'neutral' ? 'disabled' : ''}
                                        onclick="submitFeedback('${commentId}', '${sentimentClass}', 'neutral', ${index})">
                                    👐 Neutral
                                </button>
                                <button class="feedback-btn negative ${sentimentClass === 'negative' ? 'current-sentiment' : ''}" 
                                        ${sentimentClass === 'negative' ? 'disabled' : ''}
                                        onclick="submitFeedback('${commentId}', '${sentimentClass}', 'negative', ${index})">
                                    👎 Negative
                                </button>
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Add a note if there are more comments
                if (samples.length > displayLimit) {
                    el.innerHTML += `
                        <div class="text-center text-muted py-2">
                            <small><i class="fas fa-info-circle"></i> Showing ${displayLimit} of ${samples.length} ${sentimentClass} comments</small>
                        </div>
                    `;
                }
            }
        };
        
        // Helper function to escape HTML
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
        
        // Store comment data globally for feedback
        commentData.positive = positive;
        commentData.neutral = neutral;
        commentData.negative = negative;
        
        displaySamples(positive, 'positiveSamples', 'positive');
        displaySamples(neutral, 'neutralSamples', 'neutral');
        displaySamples(negative, 'negativeSamples', 'negative');
        
        // Apply stored corrections after comments are displayed
        setTimeout(() => {
            applyStoredCorrections();
        }, 100);
        
    } catch (error) {
        console.error('Error displaying sample comments:', error);
    }
}

// Submit sentiment feedback
async function submitFeedback(commentId, predictedSentiment, correctedSentiment, commentIndex) {
    // Don't submit if it's the same sentiment
    if (predictedSentiment === correctedSentiment) {
        return;
    }
    
    const videoId = '{{ video_id }}';
    const commentElement = document.getElementById(commentId);
    
    // Get the comment data
    const commentObj = commentData[predictedSentiment][commentIndex];
    if (!commentObj) {
        console.error('Comment data not found');
        return;
    }
    
    try {
        // Disable all buttons in this comment
        const buttons = commentElement.querySelectorAll('.feedback-btn');
        buttons.forEach(btn => btn.disabled = true);
        
        // Send feedback to server
        const response = await fetch('/api/sentiment-feedback', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                video_id: videoId,
                comment_id: commentObj.commentId,
                comment_text: commentObj.text,
                comment_author: commentObj.author,
                predicted_sentiment: predictedSentiment,
                corrected_sentiment: correctedSentiment,
                confidence_score: parseFloat(commentObj.confidence) / 100
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Show thank you message
            showToast(data.message || 'Thank you for your feedback!', 'success', 3000);
            
            // Apply manual correction UI instead of removing the comment
            applyManualCorrectionUI(commentElement, predictedSentiment, correctedSentiment);
            
            // Store the correction in session storage for persistence
            storeCorrectionLocally(commentObj.text, predictedSentiment, correctedSentiment);
            
        } else {
            // Re-enable buttons on error
            buttons.forEach(btn => btn.disabled = false);
            if (data.error && data.error.includes('already submitted')) {
                showToast('You\'ve already provided feedback for this comment', 'info');
            } else {
                showToast(data.error || 'Failed to submit feedback', 'warning');
            }
        }
        
    } catch (error) {
        console.error('Error submitting feedback:', error);
        showToast('Failed to submit feedback. Please try again.', 'danger');
        
        // Re-enable buttons
        const buttons = commentElement.querySelectorAll('.feedback-btn');
        buttons.forEach(btn => btn.disabled = false);
    }
}

// Apply manual correction UI to a comment
function applyManualCorrectionUI(commentElement, originalSentiment, correctedSentiment) {
    // Add manually corrected class
    commentElement.classList.add('manually-corrected');
    
    // Add correction badge
    if (!commentElement.querySelector('.manual-correction-badge')) {
        const badge = document.createElement('div');
        badge.className = 'manual-correction-badge';
        badge.innerHTML = '<i class="fas fa-user-check"></i> Manually Corrected';
        commentElement.appendChild(badge);
    }
    
    // Update feedback buttons
    const buttons = commentElement.querySelectorAll('.feedback-btn');
    buttons.forEach(btn => {
        btn.disabled = true;
        btn.classList.remove('current-sentiment', 'highlighted-correction', 'disabled-original');
        
        // Check which button corresponds to what sentiment
        if (btn.classList.contains(originalSentiment)) {
            // This was the original (wrong) prediction
            btn.classList.add('disabled-original');
        } else if (btn.classList.contains(correctedSentiment)) {
            // This is the user's correction
            btn.classList.add('highlighted-correction');
        }
    });
    
    // Add correction info if not already present
    if (!commentElement.querySelector('.correction-info')) {
        const correctionInfo = document.createElement('div');
        correctionInfo.className = 'correction-info';
        correctionInfo.innerHTML = `
            <i class="fas fa-info-circle"></i>
            <span class="original-prediction">AI predicted: ${capitalizeFirst(originalSentiment)}</span>
            <span class="user-correction">→ You corrected to: ${capitalizeFirst(correctedSentiment)}</span>
        `;
        commentElement.appendChild(correctionInfo);
    }
}

// Store correction locally for persistence
function storeCorrectionLocally(commentText, originalSentiment, correctedSentiment) {
    const videoId = '{{ video_id }}';
    const storageKey = `sentiment_corrections_${videoId}`;
    
    // Get existing corrections
    let corrections = JSON.parse(localStorage.getItem(storageKey) || '{}');
    
    // Store the correction using comment text as key (truncated for efficiency)
    const commentKey = commentText.substring(0, 100);
    corrections[commentKey] = {
        original: originalSentiment,
        corrected: correctedSentiment,
        timestamp: new Date().toISOString()
    };
    
    // Save back to localStorage
    localStorage.setItem(storageKey, JSON.stringify(corrections));
}

// Helper function to capitalize first letter
function capitalizeFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

function showError(error) {
    const progressDiv = document.getElementById('analysisProgress');
    const startButton = document.getElementById('startSentimentAnalysis');
    const startButtonMain = document.getElementById('startSentimentAnalysisMain');
    
    progressDiv.innerHTML = `
        <div class="alert alert-danger">
            <h5 class="alert-heading">Analysis Error</h5>
            <p>${error}</p>
        </div>
    `;
    
    // Re-enable both buttons
    if (startButton) {
        startButton.innerHTML = '<i class="fas fa-brain"></i> Retry Analysis';
        startButton.disabled = false;
    }
    if (startButtonMain) {
        startButtonMain.innerHTML = '<i class="fas fa-brain"></i> Retry Analysis';
        startButtonMain.disabled = false;
    }
    
    if (statusCheckInterval) {
        clearInterval(statusCheckInterval);
    }
}
</script>
{% endblock %}
