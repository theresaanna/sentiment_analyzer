{% extends "base.html" %}

{% block title %}Analysis Results - VibeCheckAI{% endblock %}

{% block extra_css %}
<style>
    .sentiment-card {
        transition: transform 0.2s;
    }
    .sentiment-card:hover {
        transform: translateY(-5px);
    }
    .progress-container {
        min-height: 200px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .analysis-section {
        display: none;
    }
    .analysis-section.active {
        display: block;
    }
    .sentiment-positive { color: #28a745; }
    .sentiment-negative { color: #dc3545; }
    .sentiment-neutral { color: #6c757d; }
    
    /* Pulse animation for analyze button */
    .pulse-animation {
        animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
        0% {
            transform: scale(1);
            box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.7);
        }
        70% {
            transform: scale(1.05);
            box-shadow: 0 0 0 10px rgba(0, 123, 255, 0);
        }
        100% {
            transform: scale(1);
            box-shadow: 0 0 0 0 rgba(0, 123, 255, 0);
        }
    }
    
    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    /* Updated stats highlighting */
    .updated-badge {
        animation: fadeIn 0.5s ease-in-out;
    }
    
    .stats-value.updated {
        animation: pulse 1s ease-in-out;
        color: #10b981 !important;
        transition: color 0.3s ease;
    }
    
    /* Free analysis button styling */
    .vibe-button.free-analysis {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        font-size: 1.1rem;
        padding: 14px 28px;
    }
    
    .free-analysis-info {
        background: linear-gradient(135deg, #f8f9ff 0%, #f0f4ff 100%);
        border: 2px solid #e0e7ff;
        border-radius: 12px;
        padding: 12px 20px;
        margin-top: 15px;
        font-size: 0.95rem;
    }
    
    .free-analysis-info strong {
        color: #5a67d8;
        font-size: 1rem;
    }
    
    .free-analysis-info small {
        display: block;
        margin-top: 5px;
        color: #6b7280;
    }
    
    /* Word cloud controls */
    .word-cloud-controls {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 15px;
    }
    
    .zoom-controls {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
    }
    
    .zoom-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
    }
    
    /* Enhanced summary styling */
    #aiSummary {
        font-size: 16px;
        line-height: 1.6;
    }
    
    #aiSummary .alert, #aiSummary .card {
        font-size: 15px;
    }
    
    #aiSummary .theme-content .badge {
        font-size: 13px;
        padding: 5px 10px;
        margin-right: 5px;
    }
    
    #aiSummary .blockquote-sm {
        font-size: 14px;
        border-left: 3px solid #dee2e6;
        padding-left: 10px;
    }
    
    #aiSummary .controversy-content {
        font-size: 14px;
    }
    
    #aiSummary ul li {
        margin-bottom: 8px;
    }
    
    .alert-heading {
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 10px;
    }
    
    .card-title {
        font-size: 16px;
        font-weight: 600;
    }
    
    /* Compact stats card styling */
    .stats-card {
        padding: 0.75rem;
    }
    
    .stats-card .stats-value {
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1;
        margin-bottom: 0.25rem;
        white-space: nowrap;
    }
    
    .stats-card .stats-label {
        font-size: 0.875rem;
        color: #6c757d;
        margin-bottom: 0;
        white-space: nowrap;
    }
    
    .stats-card .stats-icon {
        font-size: 0.75rem;
        margin-right: 0.25rem;
    }
    
    /* New compact video metadata styles */
    .video-metadata {
        background: #f8f9fa;
        border-radius: 8px;
        padding: 12px;
        font-size: 0.85rem;
    }
    
    .metadata-item {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
        padding: 4px 0;
        border-bottom: 1px solid #e9ecef;
    }
    
    .metadata-item:last-child {
        border-bottom: none;
        margin-bottom: 0;
    }
    
    .metadata-item i {
        width: 18px;
        font-size: 0.75rem;
        margin-right: 8px;
    }
    
    .metadata-label {
        font-weight: 600;
        color: #6c757d;
        margin-right: auto;
        min-width: 60px;
    }
    
    .metadata-value {
        color: #495057;
        text-align: right;
        flex: 1;
    }
    
    .metadata-value a {
        color: #007bff;
        text-decoration: none;
    }
    
    .metadata-value a:hover {
        text-decoration: underline;
    }
    
    /* Compact stats grid */
    .stats-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
    }
    
    .stat-item {
        background: white;
        border: 1px solid #e9ecef;
        border-radius: 8px;
        padding: 12px;
        display: flex;
        align-items: center;
        transition: transform 0.2s, box-shadow 0.2s;
    }
    
    .stat-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }
    
    /* Enhanced Loading Experience Styles */
    .analysis-loading-content {
        text-align: center;
        padding: 2rem;
    }
    
    /* Custom Vibe Spinner */
    .vibe-spinner {
        position: relative;
        width: 120px;
        height: 120px;
        margin: 0 auto;
    }
    
    .vibe-spinner-inner {
        position: relative;
        width: 100%;
        height: 100%;
        animation: vibeRotate 8s linear infinite;
    }
    
    .vibe-emoji {
        position: absolute;
        font-size: 2rem;
        animation: emojiPulse 2s ease-in-out infinite;
    }
    
    .vibe-emoji:nth-child(1) {
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        animation-delay: 0s;
    }
    
    .vibe-emoji:nth-child(2) {
        top: 50%;
        right: 0;
        transform: translateY(-50%);
        animation-delay: 0.5s;
    }
    
    .vibe-emoji:nth-child(3) {
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        animation-delay: 1s;
    }
    
    .vibe-emoji:nth-child(4) {
        top: 50%;
        left: 0;
        transform: translateY(-50%);
        animation-delay: 1.5s;
    }
    
    @keyframes vibeRotate {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    @keyframes emojiPulse {
        0%, 100% { 
            transform: scale(1) translateX(var(--tx, -50%)) translateY(var(--ty, 0));
            opacity: 0.7;
        }
        50% { 
            transform: scale(1.2) translateX(var(--tx, -50%)) translateY(var(--ty, 0));
            opacity: 1;
        }
    }
    
    /* Loading Status Text */
    .loading-status {
        color: #667eea;
        font-weight: 600;
        margin-bottom: 0.5rem;
        animation: fadeInOut 3s ease-in-out infinite;
    }
    
    .loading-substatus {
        color: #718096;
        font-size: 0.95rem;
        margin-bottom: 1.5rem;
        font-style: italic;
        animation: fadeInOut 4s ease-in-out infinite;
    }
    
    @keyframes fadeInOut {
        0%, 100% { opacity: 0.8; }
        50% { opacity: 1; }
    }
    
    /* Stylized Progress Bar */
    .vibe-progress-container {
        max-width: 400px;
        margin: 0 auto 2rem;
    }
    
    .vibe-progress-bar {
        height: 28px;
        background: #e2e8f0;
        border-radius: 20px;
        overflow: hidden;
        position: relative;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.08);
    }
    
    .vibe-progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
        border-radius: 20px;
        transition: width 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
        position: relative;
        width: 0%;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .vibe-progress-glow {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        width: 100px;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
        animation: progressGlow 2s linear infinite;
    }
    
    @keyframes progressGlow {
        0% { transform: translateX(-100px); }
        100% { transform: translateX(100px); }
    }
    
    .vibe-progress-text {
        margin-top: 0.75rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .vibe-progress-text #progressText {
        font-weight: 600;
        color: #667eea;
        font-size: 1.1rem;
    }
    
    .progress-detail {
        color: #718096;
        font-size: 0.85rem;
        font-style: italic;
    }
    
    /* Fun Facts Section */
    .loading-fun-fact {
        background: linear-gradient(135deg, #faf5ff 0%, #f3e7fc 100%);
        border: 1px solid #e9d5ff;
        border-radius: 12px;
        padding: 12px 20px;
        margin-top: 2rem;
        display: flex;
        align-items: center;
        gap: 10px;
        animation: slideUp 0.5s ease-out;
        max-width: 500px;
        margin-left: auto;
        margin-right: auto;
    }
    
    .loading-fun-fact i {
        color: #f59e0b;
        font-size: 1.2rem;
        animation: bulbBlink 2s ease-in-out infinite;
    }
    
    @keyframes bulbBlink {
        0%, 100% { opacity: 0.5; }
        50% { opacity: 1; }
    }
    
    @keyframes slideUp {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    #funFactText {
        flex: 1;
        color: #6b46c1;
        font-size: 0.9rem;
        transition: opacity 0.3s ease-in-out;
    }
    
    /* Error Container Animations */
    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    .error-container.animated {
        animation: fadeIn 0.5s ease-out;
    }
    
    .error-container details summary:hover {
        text-decoration: underline;
    }
    
    /* Simplified Tab Styles */
    .analysis-tabs {
        border-bottom: 2px solid #e9ecef;
        margin-bottom: 0;
    }
    
    .analysis-tabs .nav-link {
        border: none;
        border-radius: 0;
        padding: 12px 24px;
        color: #6c757d;
        font-weight: 600;
        background: transparent;
        transition: all 0.3s ease;
        position: relative;
    }
    
    .analysis-tabs .nav-link:hover {
        color: #495057;
        background: #f8f9fa;
    }
    
    .analysis-tabs .nav-link.active {
        color: #667eea;
        background: transparent;
        border: none;
    }
    
    .analysis-tabs .nav-link.active::after {
        content: '';
        position: absolute;
        bottom: -2px;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
    }
    
    .analysis-form {
        padding: 20px;
        background: #f8f9fa;
        border-radius: 8px;
    }
    
    .slider-container {
        margin-bottom: 20px;
    }
    
    .slider-label {
        display: block;
        font-weight: 600;
        margin-bottom: 10px;
        color: #2d3748;
    }
    
    .analysis-slider {
        width: 100%;
        height: 8px;
        border-radius: 4px;
        background: #e2e8f0;
        outline: none;
        -webkit-appearance: none;
    }
    
    .analysis-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        cursor: pointer;
        box-shadow: 0 2px 6px rgba(102, 126, 234, 0.4);
    }
    
    .analysis-slider::-moz-range-thumb {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        cursor: pointer;
        box-shadow: 0 2px 6px rgba(102, 126, 234, 0.4);
    }
    
    .slider-limits {
        display: flex;
        justify-content: space-between;
        margin-top: 5px;
        color: #6c757d;
        font-size: 0.85rem;
    }
    
    .analysis-stats {
        display: flex;
        justify-content: space-around;
        gap: 20px;
        padding: 15px;
        background: white;
        border-radius: 8px;
        margin-bottom: 20px;
    }
    
    .analysis-stats .stat-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.95rem;
        color: #4a5568;
    }
    
    .analysis-stats .stat-item i {
        color: #667eea;
        font-size: 1rem;
    }
    
    .analysis-stats .stat-item strong {
        color: #2d3748;
        font-size: 1.1rem;
    }
    
    .slider-range-indicators {
        display: flex;
        justify-content: space-between;
        margin-bottom: 1.5rem;
        padding: 0 10px;
        gap: 10px;
    }
    
    .range-indicator {
        flex: 1;
        padding: 8px 12px;
        background: #f7fafc;
        border: 2px solid #e2e8f0;
        border-radius: 8px;
        font-size: 0.85rem;
        font-weight: 600;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
    }
    
    .range-indicator:hover {
        background: #edf2f7;
        transform: translateY(-2px);
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .range-indicator.active {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-color: #667eea;
        transform: scale(1.05);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }
    
    .range-indicator.queue-active {
        background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
        color: white;
        border-color: #f59e0b;
    }
    
    .range-indicator.pro-active {
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        color: white;
        border-color: #059669;
    }
    
    .range-indicator .range-label {
        display: block;
        font-size: 0.9rem;
        margin-bottom: 2px;
    }
    
    .range-indicator .range-limit {
        display: block;
        font-size: 0.75rem;
        opacity: 0.8;
    }
    
    .range-indicator.disabled {
        opacity: 0.5;
        cursor: not-allowed;
        background: #f1f5f9;
    }
    
    .range-indicator.disabled:hover {
        transform: none;
        background: #f1f5f9;
        box-shadow: none;
    }
    
    .slider-container {
        margin-top: 0;
    }
    
    .coverage-slider {
        transition: background 0.3s ease;
    }
    
    .coverage-slider.queue-mode {
        background: linear-gradient(90deg, #fbbf24 0%, #f59e0b 100%);
    }
    
    .coverage-slider.pro-mode {
        background: linear-gradient(90deg, #10b981 0%, #059669 100%);
    }
    
    #analysisActionButton {
        transition: all 0.3s ease;
    }
    
    #analysisActionButton.queue-mode {
        background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
    }
    
    #analysisActionButton.pro-mode {
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    }
    
    .stat-icon {
        font-size: 1.2rem;
        margin-right: 10px;
        opacity: 0.8;
    }
    
    .stat-content {
        flex: 1;
    }
    
    .stat-value {
        font-size: 1.1rem;
        font-weight: 700;
        line-height: 1;
        margin-bottom: 2px;
        color: #2d3748;
        display: block;
    }
    
    .stat-label {
        font-size: 0.7rem;
        color: #6c757d;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    /* Comment Analysis Section Styles */
    .comment-coverage-info {
        background: #f8f9fa;
        border-radius: 8px;
        padding: 16px;
        border: 1px solid #e9ecef;
    }
    
    .coverage-summary {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    
    .coverage-main {
        display: flex;
        align-items: baseline;
        gap: 8px;
        font-size: 1.1rem;
    }
    
    .coverage-number {
        font-size: 1.8rem;
        font-weight: 700;
        color: #2d3748;
    }
    
    .coverage-text {
        color: #6c757d;
        font-size: 1rem;
    }
    
    .coverage-details {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        font-size: 0.85rem;
        color: #6c757d;
    }
    
    .detail-item {
        display: flex;
        align-items: center;
        gap: 4px;
    }
    
    .detail-item i {
        font-size: 0.75rem;
        opacity: 0.7;
    }
    
    /* Comment stats grid - same style as video stats */
    .comment-stats-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 10px;
    }
    
    /* Pro upgrade banner */
    .pro-upgrade-banner {
        background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
        border: 1px solid #667eea30;
        border-radius: 8px;
        padding: 12px;
    }
    
    .pro-banner-content {
        display: flex;
        align-items: center;
        gap: 12px;
    }
    
    .pro-star {
        font-size: 1.5rem;
        color: #667eea;
    }
    
    .pro-text {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 2px;
    }
    
    .pro-text strong {
        color: #2d3748;
        font-size: 0.95rem;
    }
    
    .pro-text span {
        color: #6c757d;
        font-size: 0.85rem;
    }
    
    .pro-upgrade-banner .btn {
        white-space: nowrap;
    }
    
    /* New coverage UI styles */
    .option-card {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 8px;
        padding: 15px;
        transition: all 0.3s;
    }
    
    .option-card:hover {
        border-color: #667eea;
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1);
    }
    
    .option-card h6 {
        color: #2d3748;
        margin-bottom: 8px;
        font-size: 1rem;
    }
    
    .option-card p {
        color: #6c757d;
        margin-bottom: 12px;
    }
    
    .pro-features-teaser {
        background: linear-gradient(135deg, #f8f9ff 0%, #f0f4ff 100%);
        border: 1px solid #e0e7ff;
        border-radius: 8px;
        padding: 15px;
        text-align: center;
    }
    
    .coverage-free-user, .coverage-logged-in {
        padding: 20px;
    }
    
    .analysis-options {
        display: flex;
        flex-direction: column;
        gap: 15px;
    }
    
    /* Editable comment count input styles */
    .stat-value-input {
        background: transparent;
        border: 1px solid transparent;
        border-radius: 4px;
        color: #2d3748;
        font-size: 1.1rem;
        font-weight: 700;
        text-align: center;
        max-width: 140px;
        padding: 2px 4px;
        transition: all 0.2s;
    }
    
    .stat-value-input:hover {
        background: #f8f9fa;
        border-color: #e9ecef;
    }
    
    .stat-value-input:focus {
        background: white;
        border-color: #667eea;
        outline: none;
        box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }
    
    .stat-value-input::-webkit-inner-spin-button,
    .stat-value-input::-webkit-outer-spin-button {
        opacity: 0;
        transition: opacity 0.2s;
    }
    
    .stat-value-input:hover::-webkit-inner-spin-button,
    .stat-value-input:hover::-webkit-outer-spin-button,
    .stat-value-input:focus::-webkit-inner-spin-button,
    .stat-value-input:focus::-webkit-outer-spin-button {
        opacity: 1;
    }
    
    /* Responsive adjustments */
    @media (max-width: 991px) {
        /* Stack video and metadata on tablets and below */
        .video-metadata {
            margin-top: 20px;
        }
        
        .stats-grid {
            grid-template-columns: repeat(4, 1fr);
        }
    }
    
    @media (max-width: 768px) {
        .stats-card .stats-value {
            font-size: 1.25rem;
        }
        .stats-card .stats-label {
            font-size: 0.8rem;
        }
        
        /* Make stats grid 2x2 on mobile */
        .stats-grid {
            grid-template-columns: 1fr 1fr;
        }
        
        /* Comment stats grid responsive - 2x2 on mobile */
        .comment-stats-grid {
            grid-template-columns: 1fr 1fr;
        }
        
        .stat-value {
            font-size: 0.95rem;
        }
        
        .stat-label {
            font-size: 0.65rem;
        }
    }
    
    @media (max-width: 480px) {
        /* Even more compact on very small screens */
        .metadata-item {
            font-size: 0.8rem;
        }
        
        .metadata-label {
            min-width: 50px;
        }
        
        .stat-item {
            padding: 8px;
        }
        
        .stat-icon {
            font-size: 1rem;
        }
    }
    
    /* Toast animation */
    @keyframes slideIn {
        from {
            transform: translateX(100%);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
    
    /* Manually corrected comment styles */
    .comment-sample-item.manually-corrected {
        background: linear-gradient(135deg, #f0f4f8 0%, #e8ecf0 100%);
        border: 2px solid #94a3b8;
        position: relative;
    }
    
    .manual-correction-badge {
        position: absolute;
        top: 8px;
        right: 8px;
        background: #3b82f6;
        color: white;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 4px;
    }
    
    .correction-info {
        background: #f8fafc;
        border: 1px solid #cbd5e1;
        border-radius: 6px;
        padding: 8px 12px;
        margin-top: 10px;
        font-size: 0.85rem;
    }
    
    .correction-info .original-prediction {
        text-decoration: line-through;
        opacity: 0.6;
        color: #64748b;
    }
    
    .correction-info .user-correction {
        color: #059669;
        font-weight: 600;
        margin-left: 8px;
    }
    
    .feedback-btn.disabled-original {
        opacity: 0.4;
        text-decoration: line-through;
        cursor: not-allowed;
        background: #e2e8f0;
    }
    
    .feedback-btn.highlighted-correction {
        background: #10b981;
        color: white;
        font-weight: 600;
        box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2);
    }
    
    @media (max-width: 576px) {
        .stats-card {
            padding: 0.5rem;
        }
        .stats-card .stats-value {
            font-size: 1.1rem;
        }
    }
    
    /* Word cloud responsive styling */
    #wordCloudContainer {
        overflow-x: auto;
        overflow-y: hidden;
    }
    
    #wordCloud {
        display: block;
        margin: 0 auto;
        background: linear-gradient(135deg, #f5f7fa 0%, #f8f9ff 100%);
    }
    
    /* Key Discussion Themes enhanced styling */
    .theme-grid {
        margin-top: 1rem;
    }
    
    .theme-item {
        background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
        border: 1px solid #e3e6f0;
        border-radius: 8px;
        padding: 12px 16px;
        margin-bottom: 10px;
        transition: all 0.3s ease;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    .theme-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        border-color: #c3c9e0;
    }
    
    .theme-item .badge {
        font-size: 16px;
        padding: 8px 14px;
        margin-right: 12px;
        font-weight: 700;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .theme-item strong {
        font-size: 22px;
        font-weight: 600;
        letter-spacing: 0.5px;
    }
    
    /* Color differentiation for high vs moderate relevance */
    .theme-item-high strong {
        color: #6f42c1;
        background: linear-gradient(90deg, #6f42c1, #8b5cf6);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }
    
    .theme-item-moderate strong {
        color: #4c6ef5;
        background: linear-gradient(90deg, #4c6ef5, #5a67d8);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }
    
    .badge-danger {
        background: linear-gradient(135deg, #8b5cf6 0%, #6f42c1 100%);
        border: none;
    }
    
    .badge-warning {
        background: linear-gradient(135deg, #5a67d8 0%, #4c6ef5 100%);
        border: none;
    }
    
    /* Mobile responsive for themes */
    @media (max-width: 768px) {
        .theme-item strong {
            font-size: 20px;
        }
        .theme-item .badge {
            font-size: 14px;
            padding: 6px 10px;
        }
        .theme-item {
            padding: 10px 14px;
        }
    }
    
    @media (max-width: 576px) {
        .theme-item strong {
            font-size: 18px;
        }
        .theme-item .badge {
            font-size: 13px;
            padding: 5px 8px;
        }
    }
    
    /* Scrollable comment samples - updated for vertical stacking */
    .comment-samples-container {
        max-height: 400px;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 15px;
        scrollbar-width: thin;
        scrollbar-color: #cbd5e0 #f7fafc;
        background: linear-gradient(to bottom, #f8f9fa 0%, #f0f2f5 100%);
        border-radius: 0 0 8px 8px;
        border: 1px solid #e9ecef;
        border-top: none;
        margin-bottom: 0;
    }
    
    /* Sentiment section styling for vertical layout */
    .sentiment-section {
        width: 100%;
    }
    
    /* Ensure full width for sentiment headers */
    .sentiment-header-section {
        width: 100%;
        margin-bottom: 0;
    }
    
    /* Sample comments body padding */
    #sampleCommentsSection .card-body {
        padding: 1.5rem;
    }
    
    /* Make sample comments section wider on larger screens */
    /* Responsive padding adjustments */
    @media (min-width: 1200px) {
        #sampleCommentsSection .card-body {
            padding: 2rem;
        }
    }
    
    @media (min-width: 1400px) {
        #sampleCommentsSection .card-body {
            padding: 2.5rem;
        }
    }
    
    /* Separate visual styling for the sample comments section - now using vibe-card */
    #sampleCommentsSection {
        margin-top: 2rem;
    }
    
    /* Sample Comments header uses default vibe-card styling */
    
    .comment-samples-container::-webkit-scrollbar {
        width: 8px;
    }
    
    .comment-samples-container::-webkit-scrollbar-track {
        background: #f7fafc;
        border-radius: 4px;
    }
    
    .comment-samples-container::-webkit-scrollbar-thumb {
        background: #cbd5e0;
        border-radius: 4px;
    }
    
    .comment-samples-container::-webkit-scrollbar-thumb:hover {
        background: #a0aec0;
    }
    
    .comment-sample-item {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 8px;
        padding: 14px;
        margin-bottom: 14px;
        transition: all 0.2s ease;
    }
    
    .comment-sample-item:hover {
        background: white;
        border-color: #dee2e6;
        transform: translateX(2px);
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    .comment-sample-text {
        font-size: 0.95rem;
        line-height: 1.6;
        margin-bottom: 10px;
        word-wrap: break-word;
        color: #2d3748;
    }
    
    .comment-sample-meta {
        font-size: 0.8rem;
        color: #6c757d;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .confidence-badge {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 2px 8px;
        border-radius: 12px;
        font-weight: 600;
        font-size: 0.75rem;
    }
    
    .comment-sample-item.positive {
        border-left: 3px solid #28a745;
    }
    
    .comment-sample-item.negative {
        border-left: 3px solid #dc3545;
    }
    
    .comment-sample-item.neutral {
        border-left: 3px solid #6c757d;
    }
    
    /* Sentiment headers styling */
    .sentiment-header-section {
        background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
        border-radius: 8px 8px 0 0;
        padding: 12px 16px;
        margin-bottom: 0;
        border: 1px solid #d1d5db;
        border-bottom: 2px solid #9ca3af;
    }
    
    .sentiment-header-section h5 {
        margin: 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 1.2rem;
    }
    
    .sentiment-positive.sentiment-header-section {
        background: linear-gradient(135deg, #d4edda 0%, #f4f9f5 100%);
        border-color: #c3e6cb;
    }
    
    .sentiment-neutral.sentiment-header-section {
        background: linear-gradient(135deg, #e2e3e5 0%, #f8f9fa 100%);
        border-color: #d6d8db;
    }
    
    .sentiment-negative.sentiment-header-section {
        background: linear-gradient(135deg, #f8d7da 0%, #fff5f5 100%);
        border-color: #f5c6cb;
    }
    
    /* Feedback buttons styling */
    .feedback-buttons {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-top: 8px;
    }
    
    .feedback-btn {
        background: none;
        border: 1px solid #dee2e6;
        border-radius: 16px;
        padding: 4px 10px;
        font-size: 0.75rem;
        cursor: pointer;
        transition: all 0.2s;
        display: inline-flex;
        align-items: center;
        gap: 4px;
        color: #6c757d;
    }
    
    .feedback-btn:hover:not(.current-sentiment) {
        background: #f8f9fa;
        border-color: #adb5bd;
        transform: scale(1.05);
    }
    
    .feedback-btn.current-sentiment {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-color: #667eea;
        cursor: default;
        font-weight: 600;
    }
    
    .feedback-btn.positive:hover:not(.current-sentiment) {
        border-color: #28a745;
        color: #28a745;
    }
    
    .feedback-btn.neutral:hover:not(.current-sentiment) {
        border-color: #6c757d;
        color: #495057;
    }
    
    .feedback-btn.negative:hover:not(.current-sentiment) {
        border-color: #dc3545;
        color: #dc3545;
    }
    
    .feedback-notice {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 12px;
        margin-top: 12px;
        font-size: 0.85rem;
        color: #6c757d;
        text-align: center;
    }
    
    .feedback-notice i {
        color: #667eea;
        margin-right: 4px;
    }
    
    @keyframes fadeOutUp {
        from {
            opacity: 1;
            transform: translateY(0);
        }
        to {
            opacity: 0;
            transform: translateY(-20px);
        }
    }
    
    .comment-sample-item.removing {
        animation: fadeOutUp 0.5s ease-out;
    }
</style>
{% endblock %}

{% block content %}
<div class="analyze-page">
    <div class="container">
        {% if success %}
        <!-- Video Embed and Info -->
        <div class="vibe-card mb-4">
            <div class="card-header-vibe">
                <h3 class="mb-0">
                    <span class="emoji-icon">ðŸ“º</span> {{ video_info.title }}
                </h3>
            </div>
            <div class="card-body">
                <div class="row">
                    <!-- Video Player Column -->
                    <div class="col-xl-8 col-lg-7 col-md-12">
                        <div class="embed-responsive embed-responsive-16by9">
                            <iframe class="embed-responsive-item" 
                                    src="https://www.youtube.com/embed/{{ video_id }}"
                                    allowfullscreen></iframe>
                        </div>
                    </div>
                    
                    <!-- Video Info Column -->
                    <div class="col-xl-4 col-lg-5 col-md-12">
                        <!-- Video Metadata -->
                        <div class="video-metadata mb-3">
                            <div class="metadata-item">
                                <i class="fas fa-tv text-muted"></i>
                                <span class="metadata-label">Channel</span>
                                <span class="metadata-value">{{ video_info.channel }}</span>
                            </div>
                            <div class="metadata-item">
                                <i class="fas fa-calendar text-muted"></i>
                                <span class="metadata-label">Published</span>
                                <span class="metadata-value">{{ video_info.published_at[:10] }}</span>
                            </div>
                            <div class="metadata-item">
                                <i class="fas fa-clock text-muted"></i>
                                <span class="metadata-label">Duration</span>
                                <span class="metadata-value">{{ video_info.duration | format_duration }}</span>
                            </div>
                            <div class="metadata-item">
                                <i class="fas fa-link text-muted"></i>
                                <span class="metadata-label">URL</span>
                                <span class="metadata-value"><a href="{{ video_url }}" target="_blank" rel="noopener">Watch <i class="fas fa-external-link-alt" style="font-size: 0.7rem;"></i></a></span>
                            </div>
                        </div>
                        
                        <!-- Compact Statistics Grid -->
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div class="stat-icon"><i class="fas fa-eye"></i></div>
                                <div class="stat-content">
                                    <div class="stat-value">{{ "{:,}".format(video_info.statistics.views) }}</div>
                                    <div class="stat-label">Views</div>
                                </div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-icon text-success"><i class="fas fa-thumbs-up"></i></div>
                                <div class="stat-content">
                                    <div class="stat-value">{{ "{:,}".format(video_info.statistics.likes) }}</div>
                                    <div class="stat-label">Likes</div>
                                </div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-icon text-info"><i class="fas fa-comment"></i></div>
                                <div class="stat-content">
                                    <div class="stat-value">{{ "{:,}".format(video_info.statistics.comments) }}</div>
                                    <div class="stat-label">Comments</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Comment Analysis -->
        <div class="vibe-card mb-4">
            <div class="card-header-vibe">
                <h3 class="mb-0">
                    <span class="emoji-icon">ðŸ’¬</span> Comment Analysis
                </h3>
            </div>
            <div class="card-body">
                <!-- Compact Comment Coverage Info -->
                <div class="comment-coverage-info mb-3">
                    <div class="coverage-summary">
                    <div class="coverage-main">
                        <span class="coverage-number comment-count-value" data-comment-total="true">{{ "{:,}".format(comment_stats.get('top_level_count', 0)) }}</span>
                        <span class="coverage-text">comments analyzed</span>
                            {% if comment_stats.fetch_percentage >= 99.9 %}
                                <span class="badge badge-success ml-2 fetch-percentage-badge">100% coverage</span>
                            {% elif comment_stats.fetch_percentage > 0 %}
                                <span class="badge badge-info ml-2 fetch-percentage-badge">{{ "%.1f"|format(comment_stats.fetch_percentage) }}% coverage</span>
                            {% endif %}
                        </div>
                        <div class="coverage-details">
                            {% if comment_stats.get('threads_fetched', 0) > 0 %}
                            <span class="detail-item">
                                <i class="fas fa-comments"></i> {{ "{:,}".format(comment_stats.get('threads_fetched', 0)) }} threads
                            </span>
                            {% endif %}
                            <span class="detail-item">
                                <i class="fas fa-clock"></i> {{ comment_stats.get('fetch_time', 0) | format_fetch_time }}
                            </span>
                            <span class="detail-item">
                                <i class="fas fa-tachometer-alt"></i> {{ "%.0f"|format(comment_stats.get('comments_per_second', 0)) }} /sec
                            </span>
                        </div>
                    </div>
                    
                </div>
                
                <!-- Comment Statistics Grid -->
                <div class="comment-stats-grid mb-4">
                    <div class="stat-item">
                        <div class="stat-icon text-primary"><i class="fas fa-users"></i></div>
                        <div class="stat-content">
                            <div class="stat-value">{{ comment_stats.get('unique_commenters', 0) }}</div>
                            <div class="stat-label">Unique Users</div>
                        </div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-icon text-success"><i class="fas fa-text-width"></i></div>
                        <div class="stat-content">
                            <div class="stat-value">{{ comment_stats.get('avg_comment_length', 0) }}</div>
                            <div class="stat-label">Avg Length</div>
                        </div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-icon text-info"><i class="fas fa-comment-dots"></i></div>
                        <div class="stat-content">
                            <div class="stat-value">{{ comment_stats.get('top_level_count', 0) }}</div>
                            <div class="stat-label">Comments</div>
                        </div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-icon text-warning"><i class="fas fa-percentage"></i></div>
                        <div class="stat-content">
                            <div class="stat-value">{{ "%.1f%%"|format((video_info.statistics.likes / video_info.statistics.views * 100) if video_info.statistics.views > 0 else 0) }}</div>
                            <div class="stat-label">Engagement</div>
                        </div>
                    </div>
                </div>
                
                {% if not current_user.is_authenticated or not current_user.is_subscribed %}
                <div class="pro-upgrade-banner mb-3">
                    <div class="pro-banner-content">
                        <i class="fas fa-star pro-star"></i>
                        <div class="pro-text">
                            <strong>Unlock Pro Analysis</strong>
                            <span>Get 100% comment coverage with advanced filtering</span>
                        </div>
                        {% if not current_user.is_authenticated %}
                            <a href="{{ url_for('auth.login') }}" class="btn btn-sm btn-primary">Sign In</a>
                        {% else %}
                            <a href="{{ url_for('auth.subscribe') }}" class="btn btn-sm btn-primary">Upgrade</a>
                        {% endif %}
                    </div>
                </div>
                {% endif %}
                
                <!-- Top Commenters -->
                {% if comment_stats.get('top_commenters') %}
                <div class="card bg-light mb-3">
                    <div class="card-header">
                        <h5 class="mb-0"><i class="fas fa-trophy"></i> Most Active Commenters</h5>
                    </div>
                    <div class="card-body">
                        <ol class="list-group list-group-flush">
                            {% for author, count in comment_stats.get('top_commenters', []) %}
                            <li class="list-group-item d-flex justify-content-between align-items-center">
                                <span><strong>#{{ loop.index }}</strong> {{ author }}</span>
                                <span class="badge badge-primary badge-pill">{{ count }} comments</span>
                            </li>
                            {% endfor %}
                        </ol>
                    </div>
                </div>
                {% endif %}
                
                <!-- Sentiment Analysis CTA -->
                <div class="text-center">
                    <!-- Analysis Coverage Section -->
                    <div class="coverage-card mb-4">
                        <div class="coverage-header">
                            <h5 class="coverage-title">
                                <span class="coverage-icon">ðŸ“Š</span>
                                Analysis Coverage
                            </h5>
                        </div>
                        
                        <div class="coverage-body">
                            <!-- Tab Navigation -->
                            <ul class="nav nav-tabs analysis-tabs" role="tablist">
                                <li class="nav-item" role="presentation">
                                    <button class="nav-link active" id="instant-tab" data-bs-toggle="tab" data-bs-target="#instant" type="button" role="tab" aria-controls="instant" aria-selected="true">
                                        <i class="fas fa-bolt"></i> Instant
                                    </button>
                                </li>
                                <li class="nav-item" role="presentation">
                                    <button class="nav-link" id="queue-tab" data-bs-toggle="tab" data-bs-target="#queue" type="button" role="tab" aria-controls="queue" aria-selected="false">
                                        <i class="fas fa-clock"></i> Queue
                                    </button>
                                </li>
                            </ul>
                            
                            <!-- Tab Content -->
                            <div class="tab-content mt-4">
                                <!-- Instant Tab -->
                                <div class="tab-pane fade show active" id="instant" role="tabpanel" aria-labelledby="instant-tab">
                                    <div class="analysis-form">
                                        <h6 class="text-muted mb-3" id="analysisTypeHeader">Instant Analysis</h6>
                                        
                                        <!-- Instant Slider -->
                                        <div class="slider-container mb-3">
                                            <label for="instantSlider" class="slider-label">Comments: <span id="instantValue">100</span></label>
                                            <input type="range" 
                                                   class="form-range coverage-slider" 
                                                   id="instantSlider"
                                                   min="1" 
                                                   max="500" 
                                                   step="1" 
                                                   value="100">
                                            <div class="slider-limits">
                                                <small>1</small>
                                                <small id="instantMax">500</small>
                                            </div>
                                        </div>
                                        
                                        <!-- Instant Stats -->
                                        <div class="analysis-stats mb-3">
                                            <span class="stat-item">
                                                <i class="fas fa-percentage"></i>
                                                Coverage: <strong id="instantCoverage">2%</strong>
                                            </span>
                                            <span class="stat-item">
                                                <i class="fas fa-clock"></i>
                                                Time: <strong>~5s</strong>
                                            </span>
                                        </div>
                                        
                                        <!-- Instant Button -->
                                        <button class="btn btn-primary btn-lg btn-block" id="instantAnalyzeBtn">
                                            <i class="fas fa-bolt"></i> Analyze
                                        </button>
                                    </div>
                                </div>
                                
                                <!-- Queue Tab -->
                                <div class="tab-pane fade" id="queue" role="tabpanel" aria-labelledby="queue-tab">
                                    <div class="analysis-form">
                                        <h6 class="text-muted mb-3" id="queueAnalysisHeader">Queue Analysis</h6>
                                        
                                        {% if not current_user.is_authenticated %}
                                            <!-- Not logged in -->
                                            <div class="alert alert-info">
                                                <i class="fas fa-lock"></i> Sign in to queue analysis
                                                <div class="mt-3">
                                                    <a href="{{ url_for('auth.login') }}" class="btn btn-sm btn-primary">Sign In</a>
                                                    <a href="{{ url_for('auth.register') }}" class="btn btn-sm btn-outline-primary">Create Account</a>
                                                </div>
                                            </div>
                                        {% else %}
                                            <!-- Queue Slider -->
                                            <div class="slider-container mb-3">
                                                <label for="queueSlider" class="slider-label">Comments: <span id="queueValue">1000</span></label>
                                                <input type="range" 
                                                       class="form-range coverage-slider" 
                                                       id="queueSlider"
                                                       min="1" 
                                                       max="{{ [comment_stats.get('top_level_count', 2500), 2500 if not current_user.is_subscribed else 5000]|min }}"
                                                       step="{% if comment_stats.get('top_level_count', 2500) < 100 %}1{% else %}10{% endif %}" 
                                                       value="{% if comment_stats.get('top_level_count', 2500) < 100 %}{{ [comment_stats.get('top_level_count', 10), 10]|min }}{% elif comment_stats.get('top_level_count', 2500) < 1000 %}100{% else %}1000{% endif %}">
                                            <div class="slider-limits">
                                                <small>1</small>
                                                <small id="queueMax">{% if comment_stats.get('top_level_count', 0) < 1000 %}{{ comment_stats.get('top_level_count', 2500) }}{% else %}{{ '2.5k' if not current_user.is_subscribed else '5k' }}{% endif %}</small>
                                            </div>
                                            </div>
                                            
                                            <!-- Queue Stats -->
                                            <div class="analysis-stats mb-3">
                                                <span class="stat-item">
                                                    <i class="fas fa-percentage"></i>
                                                    Coverage: <strong id="queueCoverage">20%</strong>
                                                </span>
                                                <span class="stat-item">
                                                    <i class="fas fa-clock"></i>
                                                    Time: <strong>~2 min</strong>
                                                </span>
                                            </div>
                                            
                                            <!-- Queue Button -->
                                            <button class="btn btn-warning btn-lg btn-block" id="queueAnalyzeBtn">
                                                <i class="fas fa-clock"></i> Queue Analysis
                                            </button>
                                            
                                            {% if not current_user.is_subscribed %}
                                                <div class="mt-3 text-center">
                                                <small class="text-muted">
                                                    <i class="fas fa-crown"></i> Upgrade to Pro for up to 5,000 comments (currently 2,500 limit)
                                                        <br>
                                                        <a href="{{ url_for('auth.subscribe') }}">Learn More</a>
                                                    </small>
                                                </div>
                                            {% endif %}
                                        {% endif %}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Sentiment Analysis Section -->
        <div id="sentimentAnalysisSection" class="vibe-card mb-4 analysis-section" style="display: none;">
            <div class="card-header-vibe d-flex justify-content-between align-items-center">
                <h3 class="mb-0">
                    <span class="emoji-icon">ðŸ§ </span> Sentiment Analysis
                </h3>
                <button id="startSentimentAnalysis" class="vibe-button small">
                    <span class="button-icon">ðŸ§ </span>
                    <span class="button-text">Analyze Sentiment</span>
                </button>
            </div>
            <div class="card-body">
                <!-- Progress Section -->
                <div id="analysisProgress" class="progress-container">
                    <div class="analysis-loading-content">
                        <!-- Custom animated vibes spinner -->
                        <div class="vibe-spinner mb-4">
                            <div class="vibe-spinner-inner">
                                <span class="vibe-emoji">ðŸŽ­</span>
                                <span class="vibe-emoji">ðŸ˜Š</span>
                                <span class="vibe-emoji">ðŸ˜</span>
                                <span class="vibe-emoji">ðŸ˜”</span>
                            </div>
                        </div>
                        
                        <h4 id="progressStatus" class="loading-status">Initializing vibe check...</h4>
                        <p id="progressSubStatus" class="loading-substatus">Warming up the sentiment engines...</p>
                        
                        <!-- Styled progress bar -->
                        <div class="vibe-progress-container">
                            <div class="vibe-progress-bar">
                                <div id="progressBar" class="vibe-progress-fill">
                                    <div class="vibe-progress-glow"></div>
                                </div>
                            </div>
                            <div class="vibe-progress-text">
                                <span id="progressText">0%</span>
                                <span id="progressDetail" class="progress-detail"></span>
                            </div>
                        </div>
                        
                        <!-- Fun facts during loading -->
                        <div id="loadingFunFact" class="loading-fun-fact">
                            <i class="fas fa-lightbulb"></i>
                            <span id="funFactText">Did you know? The average YouTube comment is 27 words long!</span>
                        </div>
                    </div>
                </div>
                
                <!-- Results Section (hidden initially) -->
                <div id="analysisResults" style="display: none;">
                    <!-- Overall Sentiment -->
                    <div class="row mb-4">
                        <div class="col-md-12">
                            <div class="alert alert-info">
                                <h4 class="alert-heading"><i class="fas fa-chart-line"></i> Overall Sentiment</h4>
                                <p id="overallSentiment" class="mb-0"></p>
                            </div>
                        </div>
                    </div>
                    
                    
                    <!-- Charts Row -->
                    <div class="row mb-4">
                        <div class="col-md-12">
                            <div class="card">
<div class="card-header header-muted-blue">
                                    <h5 class="mb-0"><i class="fas fa-chart-pie"></i> Sentiment Distribution</h5>
                                </div>
                                <div class="card-body">
                                    <canvas id="sentimentPieChart" width="400" height="400"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- AI Summary -->
                    <div class="card mb-4">
<div class="card-header header-muted-blue">
                            <h5 class="mb-0"><i class="fas fa-robot"></i> AI Analysis Summary</h5>
                        </div>
                        <div class="card-body">
                            <div id="aiSummary" class="lead"></div>
                        </div>
                    </div>
                    
                    <!-- Sentiment Timeline -->
                    <div class="card mb-4">
                        <div class="card-header header-muted-blue">
                            <h5 class="mb-0"><i class="fas fa-clock"></i> Sentiment Timeline</h5>
                        </div>
                        <div class="card-body">
                            <canvas id="sentimentTimelineChart" width="400" height="200"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Sample Comments Section (Standalone, Wider) -->
        <div id="sampleCommentsSection" class="vibe-card mb-4 analysis-section" style="display: none;">
            <div class="card-header-vibe">
                <h3 class="mb-0">
                    <span class="emoji-icon">ðŸ’¬</span> Sample Comments by Sentiment
                </h3>
            </div>
            <div class="card-body">
                <!-- Positive Comments Section -->
                <div class="sentiment-section mb-4">
                    <div class="sentiment-positive sentiment-header-section">
                        <h5>
                            <span><i class="fas fa-smile"></i> Positive</span>
                            <span class="badge" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;" id="positiveCount">0</span>
                        </h5>
                    </div>
                    <div id="positiveSamples" class="comment-samples-container"></div>
                </div>
                
                <!-- Neutral Comments Section -->
                <div class="sentiment-section mb-4">
                    <div class="sentiment-neutral sentiment-header-section">
                        <h5>
                            <span><i class="fas fa-meh"></i> Neutral</span>
                            <span class="badge" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;" id="neutralCount">0</span>
                        </h5>
                    </div>
                    <div id="neutralSamples" class="comment-samples-container"></div>
                </div>
                
                <!-- Negative Comments Section -->
                <div class="sentiment-section mb-4">
                    <div class="sentiment-negative sentiment-header-section">
                        <h5>
                            <span><i class="fas fa-frown"></i> Negative</span>
                            <span class="badge" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;" id="negativeCount">0</span>
                        </h5>
                    </div>
                    <div id="negativeSamples" class="comment-samples-container"></div>
                </div>
                <!-- Feedback Notice -->
                <div class="feedback-notice mt-3">
                    <i class="fas fa-robot"></i>
                    Your feedback helps us improve our AI models. Click the sentiment buttons to correct any misclassifications.
                </div>
            </div>
        </div>
        
        {% else %}
        <!-- Error State -->
        <div class="card shadow">
            <div class="card-header bg-danger text-white">
                <h3 class="mb-0">
                    <i class="fas fa-exclamation-triangle"></i> Analysis Error
                </h3>
            </div>
            <div class="card-body">
                <div class="alert alert-danger">
                    <h5 class="alert-heading">Unable to analyze video</h5>
                    <p>{{ error }}</p>
                </div>
            </div>
        </div>
        {% endif %}
        
        <div class="text-center mt-4">
            <a href="{{ url_for('main.index') }}" class="vibe-button secondary">
                <span class="button-icon">â¬…</span> Analyze Another Video
            </a>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<!-- Chart.js for visualization -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<!-- WordCloud2.js for word cloud visualization -->
<script src="https://cdn.jsdelivr.net/npm/wordcloud@1.2.2/src/wordcloud2.min.js"></script>

<script>
// Global variables
let analysisId = null;
let statusCheckInterval = null;
let charts = {};
let currentAnalysisMode = 'instant'; // Default to instant mode
let commentData = {
    positive: [],
    neutral: [],
    negative: []
};
let instantSlider = null; // Will be initialized in DOMContentLoaded
let commentCountInput = null; // Legacy support, will be initialized if needed

// Define showToast function globally so it can be used by submitFeedback
function showToast(message, type = 'info', duration = 3000) {
    // Create toast container if it doesn't exist
    let toastContainer = document.getElementById('toastContainer');
    if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.id = 'toastContainer';
        toastContainer.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 9999;';
        document.body.appendChild(toastContainer);
    }
    
    // Create toast element
    const toast = document.createElement('div');
    toast.className = `alert alert-${type === 'success' ? 'success' : type === 'danger' ? 'danger' : type === 'warning' ? 'warning' : 'info'} alert-dismissible fade show`;
    toast.style.cssText = 'min-width: 250px; margin-bottom: 10px; animation: slideIn 0.3s ease-out;';
    toast.setAttribute('role', 'alert');
    
    // Add icon based on type
    const icon = type === 'success' ? 'âœ“' : type === 'danger' ? 'âœ•' : type === 'warning' ? 'âš ' : 'â„¹';
    
    toast.innerHTML = `
        <strong>${icon}</strong> ${message}
        <button type="button" class="close" data-dismiss="alert" aria-label="Close">
            <span aria-hidden="true">&times;</span>
        </button>
    `;
    
    // Add toast to container
    toastContainer.appendChild(toast);
    
    // Auto-dismiss after duration
    setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
            toast.remove();
        }, 150);
    }, duration);
}

// Load user's previous feedback corrections
async function loadUserFeedback() {
    const videoId = '{{ video_id }}';
    
    try {
        // Fetch feedback from server
        const response = await fetch(`/api/sentiment-feedback?video_id=${videoId}`);
        const data = await response.json();
        
        if (data.success && data.feedback.length > 0) {
            // Store server feedback in localStorage for consistency
            const storageKey = `sentiment_corrections_${videoId}`;
            const corrections = {};
            
            data.feedback.forEach(fb => {
                const commentKey = fb.comment_text.substring(0, 100);
                corrections[commentKey] = {
                    original: fb.predicted_sentiment,
                    corrected: fb.corrected_sentiment,
                    timestamp: fb.created_at
                };
            });
            
            localStorage.setItem(storageKey, JSON.stringify(corrections));
            return corrections;
        }
    } catch (error) {
        console.error('Error loading user feedback:', error);
    }
    
    // Fall back to localStorage
    const storageKey = `sentiment_corrections_${videoId}`;
    return JSON.parse(localStorage.getItem(storageKey) || '{}');
}

// Apply stored corrections to displayed comments
function applyStoredCorrections() {
    const videoId = '{{ video_id }}';
    const storageKey = `sentiment_corrections_${videoId}`;
    const corrections = JSON.parse(localStorage.getItem(storageKey) || '{}');
    
    // Check each displayed comment for corrections
    Object.keys(commentData).forEach(sentiment => {
        commentData[sentiment].forEach((comment, index) => {
            const commentKey = comment.text.substring(0, 100);
            const correction = corrections[commentKey];
            
            if (correction) {
                // Find the comment element
                const commentId = `comment-${sentiment}-${index}`;
                const commentElement = document.getElementById(commentId);
                
                if (commentElement) {
                    // Apply the correction UI
                    applyManualCorrectionUI(commentElement, correction.original, correction.corrected);
                }
            }
        });
    });
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', async function() {
    console.log('DOMContentLoaded fired - initializing analyze page');
    
    // Use only top-level comment counts throughout
    const topLevelCount = {{ comment_stats.get('top_level_count', 0) }};
    const totalComments = topLevelCount;  // Always use top-level count only
    
    // Check if we have precomputed results from a completed job
    {% if precomputed_results %}
    console.log('Found precomputed results from job, displaying immediately');
    // Show sentiment analysis section and results
    const section = document.getElementById('sentimentAnalysisSection');
    const progressDiv = document.getElementById('analysisProgress');
    const resultsDiv = document.getElementById('analysisResults');
    
    if (section) {
        section.style.display = 'block';
        section.classList.add('active');
    }
    if (progressDiv) progressDiv.style.display = 'none';
    if (resultsDiv) resultsDiv.style.display = 'block';
    
    // Display the precomputed results
    const precomputedData = {{ precomputed_results|tojson }};
    console.log('Precomputed data:', precomputedData);
    
    // Format it correctly for displayResults function
    const formattedResults = {
        sentiment: {
            overall_sentiment: precomputedData.overall_sentiment || 'neutral',
            distribution: precomputedData.distribution || {positive: 0, neutral: 0, negative: 0},
            distribution_percentage: precomputedData.percentages || {positive: 0, neutral: 0, negative: 0},
            sentiment_counts: precomputedData.distribution || {positive: 0, neutral: 0, negative: 0},
            sentiment_percentages: precomputedData.percentages || {positive: 0, neutral: 0, negative: 0},
            average_confidence: precomputedData.average_confidence || 0,
            sentiment_score: precomputedData.sentiment_score || 0,
            total_analyzed: precomputedData.total_analyzed || 0,
            individual_results: precomputedData.individual_results || [],
            model: precomputedData.model || 'enhanced-sentiment-v1'
        },
        summary: {
            summary: precomputedData.summary || 'Analysis completed successfully.'
        }
    };
    
    console.log('Formatted results:', formattedResults);
    displayResults(formattedResults);
    
    // Update comment statistics if we have updated_stats from the job
    {% if updated_stats %}
    console.log('Found updated_stats from job, updating comment statistics display');
    const updatedStats = {{ updated_stats|tojson }};
    updateCommentStatistics(updatedStats);
    {% endif %}
    
    // Show sample comments section
    const samplesSection = document.getElementById('sampleCommentsSection');
    if (samplesSection) {
        samplesSection.style.display = 'block';
    }
    {% endif %}
    
    
    // Load user's previous feedback first
    await loadUserFeedback();
    
    // Get comment statistics - use top-level counts only
    const fetchedComments = {{ comment_stats.get('top_level_count', 0) }};
    const totalAvailable = {{ comment_stats.get('total_top_level_comments', comment_stats.get('total_available', 0)) }};
    const videoStatsComments = {{ (video_info.statistics.comments if video_info else 0)|default(0) }};
    
    console.log('Debug - totalAvailable (top-level):', totalAvailable);
    console.log('Debug - videoStatsComments:', videoStatsComments);
    console.log('Debug - fetchedComments (top-level):', fetchedComments);
    
    // Use the top-level count as the total
    let totalAvailableComments = totalAvailable || fetchedComments || 5000;
    console.log('Debug - totalAvailableComments used:', totalAvailableComments);
    
    // Set current total to top-level comments only
    window.currentTotalComments = totalAvailableComments;
    
    // Use global isAuthenticated and isProUser variables
    console.log('User status - isAuthenticated:', isAuthenticated, 'isProUser:', isProUser);
    
    // Legacy button support for sentiment analysis section
    const startButton = document.getElementById('startSentimentAnalysis');
    if (startButton) {
        startButton.addEventListener('click', startSentimentAnalysis);
    }
    
    // ============= SIMPLIFIED TAB-BASED HANDLERS =============
    
    // Get slider elements (update global references)
    instantSlider = document.getElementById('instantSlider');
    const queueSlider = document.getElementById('queueSlider');
    const instantValue = document.getElementById('instantValue');
    const queueValue = document.getElementById('queueValue');
    const instantCoverage = document.getElementById('instantCoverage');
    const queueCoverage = document.getElementById('queueCoverage');
    const instantAnalyzeBtn = document.getElementById('instantAnalyzeBtn');
    const queueAnalyzeBtn = document.getElementById('queueAnalyzeBtn');
    
    // Configure sliders based on user status and video
    function configureSlidersForUser() {
        const effectiveTotal = window.currentTotalComments || totalAvailableComments;
        
        // Configure instant slider - always max 500 for instant
        if (instantSlider) {
            const instantMax = Math.min(500, effectiveTotal);
            instantSlider.max = instantMax;
            document.getElementById('instantMax').textContent = instantMax;
            updateInstantSlider();
        }
        
        // Configure queue slider based on user status
        if (queueSlider && isAuthenticated) {
            let queueMax;
            if (isProUser) {
                queueMax = Math.min(5000, effectiveTotal);
            } else {
                queueMax = Math.min(2500, effectiveTotal);
            }
            queueSlider.max = queueMax;
            queueSlider.min = 1;
            
            // Set appropriate value based on available comments
            if (queueMax < 100) {
                queueSlider.value = Math.min(queueMax, 10);
                queueSlider.step = 1;
            } else if (queueMax < 1000) {
                queueSlider.value = Math.min(100, queueMax);
                queueSlider.step = 10;
            } else {
                queueSlider.value = 1000;
                queueSlider.step = 10;
            }
            
            const queueMaxLabel = document.getElementById('queueMax');
            if (queueMaxLabel) {
                // Format max label appropriately - just show the number
                if (queueMax < 1000) {
                    queueMaxLabel.textContent = queueMax.toString();
                } else {
                    // Format as k with proper decimals (2.5k, 5k, etc)
                    const kValue = (queueMax/1000).toFixed(1);
                    queueMaxLabel.textContent = kValue.replace('.0', '') + 'k';
                }
            }
            updateQueueSlider();
        }
    }
    
    // Update instant slider display
    function updateInstantSlider() {
        if (!instantSlider) return;
        
        const value = parseInt(instantSlider.value);
        const effectiveTotal = window.currentTotalComments || totalAvailableComments;
        const percentage = Math.min(100, Math.round((value / effectiveTotal) * 100));
        
        if (instantValue) instantValue.textContent = value;
        if (instantCoverage) instantCoverage.textContent = `${percentage}%`;
        
        // Update time estimate for instant mode
        const timeEstimate = value <= 100 ? '~5s' : value <= 300 ? '~15s' : '~30s';
        const timeSpan = document.querySelector('#instant .analysis-stats .stat-item:nth-child(2) strong');
        if (timeSpan) timeSpan.textContent = timeEstimate;
    }
    
    // Update queue slider display
    function updateQueueSlider() {
        if (!queueSlider) return;
        
        const value = parseInt(queueSlider.value) || 1;
        const effectiveTotal = window.currentTotalComments || totalAvailableComments;
        const percentage = Math.min(100, Math.round((value / effectiveTotal) * 100));
        
        // Format value display based on size
        if (queueValue) {
            if (value < 1000) {
                queueValue.textContent = value.toString();
            } else {
                queueValue.textContent = value.toLocaleString();
            }
        }
        
        if (queueCoverage) queueCoverage.textContent = `${percentage}%`;
        
        // Update time estimate for queue mode
        const seconds = Math.round(value * 0.12); // ~0.12 seconds per comment
        let timeEstimate;
        if (seconds < 60) {
            timeEstimate = `~${seconds}s`;
        } else {
            const minutes = Math.round(seconds / 60);
            timeEstimate = minutes === 1 ? '~1 min' : `~${minutes} min`;
        }
        const timeSpan = document.querySelector('#queue .analysis-stats .stat-item:nth-child(2) strong');
        if (timeSpan) timeSpan.textContent = timeEstimate;
    }
    
    // Initialize sliders
    configureSlidersForUser();
    
    // Add event listeners for instant slider
    if (instantSlider) {
        instantSlider.addEventListener('input', updateInstantSlider);
        instantSlider.addEventListener('change', updateInstantSlider);
        // Initialize display values
        updateInstantSlider();
    }
    
    // Add event listeners for queue slider  
    if (queueSlider) {
        queueSlider.addEventListener('input', updateQueueSlider);
        queueSlider.addEventListener('change', updateQueueSlider);
        // Initialize display values
        updateQueueSlider();
    }
    
    // Handle tab switching with vanilla JavaScript and Bootstrap 5
    const instantTab = document.getElementById('instant-tab');
    const queueTab = document.getElementById('queue-tab');
    const instantPane = document.getElementById('instant');
    const queuePane = document.getElementById('queue');
    
    // Listen for tab shown events (Bootstrap 5)
    if (instantTab) {
        instantTab.addEventListener('shown.bs.tab', function (event) {
            console.log('Switched to Instant tab');
            currentAnalysisMode = 'instant';
            // Update header if needed
            const header = document.getElementById('analysisTypeHeader');
            if (header) header.textContent = 'Instant Analysis';
            updateInstantSlider();
        });
    }
    
    if (queueTab) {
        queueTab.addEventListener('shown.bs.tab', function (event) {
            console.log('Switched to Queue tab');
            currentAnalysisMode = 'queue';
            // Update header
            const header = document.getElementById('queueAnalysisHeader');
            if (header) header.textContent = 'Queue Analysis';
            updateQueueSlider();
            
            // If not authenticated, the tab content will show login prompt
            if (!isAuthenticated) {
                console.log('User not authenticated, showing login prompt in Queue tab');
            }
        });
    }
    
    // Manual tab switching function for programmatic use
    function switchToTab(tabName) {
        if (tabName === 'instant' && instantTab) {
            // Use Bootstrap 5 Tab API
            const tab = new bootstrap.Tab(instantTab);
            tab.show();
        } else if (tabName === 'queue' && queueTab) {
            const tab = new bootstrap.Tab(queueTab);
            tab.show();
        }
    }
    
    // Add click handlers for analyze buttons
    if (instantAnalyzeBtn) {
        instantAnalyzeBtn.addEventListener('click', function(e) {
            e.preventDefault();
            const value = parseInt(instantSlider.value);
            startAnalysisWithMode('instant', value);
        });
    }
    
    if (queueAnalyzeBtn) {
        queueAnalyzeBtn.addEventListener('click', function(e) {
            e.preventDefault();
            const value = parseInt(queueSlider.value);
            startAnalysisWithMode('queue', value);
        });
    }
    // New simplified analysis function
    function startAnalysisWithMode(mode, commentsToAnalyze) {
        console.log('Starting analysis with mode:', mode, 'comments:', commentsToAnalyze);
        
        // Store the mode globally
        currentAnalysisMode = mode;
        
        if (mode === 'queue') {
            // Queue mode - handle authentication
            if (!isAuthenticated) {
                // Show authentication required message
                showToast('Please sign in to use Queue mode', 'warning');
                // Could also trigger a modal or redirect here
                if (typeof showLoginPrompt === 'function') {
                    showLoginPrompt();
                }
                return;
            }
            
            // Create a background job
            const videoId = '{{ video_id }}';
            const button = queueAnalyzeBtn;
            
            // Disable button with loading state
            if (button) {
                button.disabled = true;
                button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Queueing...';
            }
            
            fetch('/api/analyze/queue', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    video_id: videoId,
                    comment_count: commentsToAnalyze,
                    include_replies: false
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const estimatedMinutes = Math.round((commentsToAnalyze / 100) * 1.5 / 60);
                    const timeText = estimatedMinutes > 1 ? `${estimatedMinutes} minutes` : '1 minute';
                    showToast(`Analysis queued! Estimated time: ~${timeText}`, 'success');
                    
                    // Redirect to the analysis status page
                    setTimeout(() => {
                        window.location.href = `/analysis/${data.job_id}`;
                    }, 1500);
                } else {
                    showToast(`Error: ${data.error}`, 'error');
                    // Re-enable button
                    if (button) {
                        button.disabled = false;
                        button.innerHTML = '<i class="fas fa-clock"></i> Queue Analysis';
                    }
                }
            })
            .catch(error => {
                console.error('Error queueing analysis:', error);
                showToast('Failed to queue analysis', 'error');
                // Re-enable button
                if (button) {
                    button.disabled = false;
                    button.innerHTML = '<i class="fas fa-clock"></i> Queue Analysis';
                }
            });
        } else {
            // Instant mode - direct analysis
            console.log('Starting instant analysis with', commentsToAnalyze, 'comments');
            
            // Show sentiment analysis section
            const section = document.getElementById('sentimentAnalysisSection');
            if (section) {
                section.style.display = 'block';
                section.classList.add('active');
            }
            
            // Show progress, hide results
            const progressDiv = document.getElementById('analysisProgress');
            const resultsDiv = document.getElementById('analysisResults');
            if (progressDiv) progressDiv.style.display = 'flex';
            if (resultsDiv) resultsDiv.style.display = 'none';
            
            // Start the analysis
            const videoId = '{{ video_id }}';
            initiateAnalysis(videoId, commentsToAnalyze, Math.round((commentsToAnalyze / (window.currentTotalComments || 5000)) * 100));
        }
    }
    
});


function formatEnhancedSummary(insights) {
    // Convert the detailed insights into well-formatted HTML
    if (!insights) return '';
    
    // Split by sections and format each
    const lines = insights.split('\n');
    let html = '';
    let inSection = false;
    let inThemeSection = false;
    
    lines.forEach(line => {
        // Skip empty lines
        if (!line.trim()) {
            if (inSection) {
                html += '</div>';
                inSection = false;
            }
            return;
        }
        
        // Format main section headers with emojis
        if (line.includes('ðŸ“Š SENTIMENT LANDSCAPE:')) {
            if (inSection) html += '</div>';
            const content = line.replace('ðŸ“Š SENTIMENT LANDSCAPE:', '').trim();
            html += `
                <div class="alert alert-info mb-3">
                    <h6 class="alert-heading"><i class="fas fa-chart-pie"></i> Sentiment Landscape</h6>
                    <p class="mb-0">${content}</p>
            `;
            inSection = true;
        }
        else if (line.includes('ðŸŽ¯ KEY DISCUSSION THEMES:')) {
            // Skip rendering this section here; themes are rendered by the dedicated component
            if (inSection) {
                html += '</div>';
                inSection = false;
            }
            inThemeSection = false;
            // Do not output anything for this section
        }
        // Skip sub-items (remove text without headers)
        else if (line.trim().startsWith('-')) {
            // intentionally omitted
        }
        // Format numbered items (themes)
        else if (inThemeSection && line.match(/^\s+\d+\./)) {
            const content = line.trim();
            const parts = content.match(/^(\d+)\. '([^']+)' - (.+) \(score: ([\d.]+)\)/);
            if (parts) {
                const [, num, theme, relevance, score] = parts;
                // Skip "Emerging topic" - only show High and Moderate relevance
                if (!relevance.includes('Emerging')) {
                    const isHigh = relevance.includes('High');
                    const badgeClass = isHigh ? 'badge-danger' : 'badge-warning';
                    const iconClass = isHigh ? 'fas fa-fire' : 'fas fa-star';
                    const themeClass = isHigh ? 'theme-item-high' : 'theme-item-moderate';
                    // Start row div if needed
                    if (!html.includes('theme-grid')) {
                        html += '<div class="row theme-grid">';
                    }
                    html += `
                        <div class="col-md-6 mb-3">
                            <div class="theme-item ${themeClass}">
                                <div class="d-flex align-items-center">
                                    <span class="badge ${badgeClass}">
                                        <i class="${iconClass} mr-1"></i>${num}
                                    </span>
                                    <strong>${theme}</strong>
                                </div>
                            </div>
                        </div>
                    `;
                }
            } else {
                html += `<div class="ml-3">${content}</div>`;
            }
        }
        // Skip regular text lines without headers between sections
        else if (line.trim()) {
            // intentionally omitted
        }
    });
    
    // Close any open sections
    if (inSection) {
        // Close theme grid if open
        if (inThemeSection && html.includes('theme-grid')) {
            html += '</div>'; // Close row
            html += '</div>'; // Close theme-content
        }
        if (html.includes('<ul') && !html.endsWith('</ul>')) {
            html += '</ul>';
        }
        if (!inThemeSection) {
            html += '</div>'; // Close alert or other containers
        }
        if (html.includes('card-body')) {
            html += '</div></div>'; // Close card-body and card
        }
    }
    
    return html;
}


function updateCommentStatistics(stats) {
    // Update stats for all users when sentiment analysis is done
    if (!stats) return;
    
    // Add a visual indicator that stats have been updated
    const commentAnalysisHeaders = document.querySelectorAll('.card-header-vibe h3');
    const commentAnalysisHeader = commentAnalysisHeaders[1]; // Second header is Comment Analysis
    if (commentAnalysisHeader && !commentAnalysisHeader.querySelector('.updated-badge')) {
        const badge = document.createElement('span');
        badge.className = 'badge badge-success ml-2 updated-badge';
        badge.textContent = 'Updated';
        badge.style.fontSize = '0.6em';
        badge.style.verticalAlign = 'middle';
        badge.style.animation = 'fadeIn 0.5s';
        commentAnalysisHeader.appendChild(badge);
    }
    
    // Update the alert with analyzed count
    const alertInfo = document.querySelector('.alert-info');
    if (alertInfo && stats.total_analyzed) {
        const newAlertContent = `
            <i class="fas fa-info-circle"></i> 
            <strong>Analysis Updated:</strong> Analyzed <strong>${stats.total_analyzed}</strong> comments 
            (<strong>${stats.analysis_depth_percentage}%</strong> of total available)
            <br>
            <small class="text-muted">
                <i class="fas fa-chart-line"></i> Statistics below reflect the expanded analysis dataset
            </small>
        `;
        alertInfo.innerHTML = newAlertContent;
        alertInfo.classList.add('alert-success');
        alertInfo.classList.remove('alert-info');
    }
    
    // Update individual stat cards with animation
    const updateStatCard = (selector, value, isFormattedNumber = false) => {
        const element = document.querySelector(selector);
        if (element) {
            const oldValue = element.textContent;
            if (isFormattedNumber) {
                element.textContent = value.toLocaleString();
            } else {
                element.textContent = value;
            }
            // Add highlight effect if value changed
            if (oldValue !== element.textContent) {
                element.style.animation = 'pulse 1s';
                element.style.color = '#10b981';
                setTimeout(() => {
                    element.style.animation = '';
                    element.style.color = '';
                }, 1000);
            }
        }
    };
    
    // Update each statistic - using the correct selectors for the new grid layout
    const commentStatsGrid = document.querySelector('.comment-stats-grid');
    if (commentStatsGrid) {
        // Update Unique Users
        const uniqueUsersEl = commentStatsGrid.querySelector('.stat-item:nth-child(1) .stat-value');
        if (uniqueUsersEl) {
            uniqueUsersEl.textContent = stats.unique_commenters || 0;
        }
        
        // Update Avg Length
        const avgLengthEl = commentStatsGrid.querySelector('.stat-item:nth-child(2) .stat-value');
        if (avgLengthEl) {
            avgLengthEl.textContent = stats.avg_comment_length || 0;
        }
        
        // Update Threads (top_level_count)
        const threadsEl = commentStatsGrid.querySelector('.stat-item:nth-child(3) .stat-value');
        if (threadsEl) {
            threadsEl.textContent = stats.top_level_count || 0;
        }
        
        // Update Replies
        const repliesEl = commentStatsGrid.querySelector('.stat-item:nth-child(4) .stat-value');
        if (repliesEl) {
            repliesEl.textContent = stats.replies_count || 0;
        }
    }
    
    // Update top commenters if present
    if (stats.top_commenters && stats.top_commenters.length > 0) {
        const topCommentersContainer = document.querySelector('.list-group-flush');
        if (topCommentersContainer) {
            topCommentersContainer.innerHTML = '';
            stats.top_commenters.forEach((commenter, index) => {
                const li = document.createElement('li');
                li.className = 'list-group-item d-flex justify-content-between align-items-center';
                li.innerHTML = `
                    <span><strong>#${index + 1}</strong> ${commenter[0]}</span>
                    <span class="badge badge-primary badge-pill">${commenter[1]} comments</span>
                `;
                topCommentersContainer.appendChild(li);
            });
        }
    }
}

// Global user authentication status
const isAuthenticated = {{ current_user.is_authenticated|tojson|default('false') }};
const isProUser = {{ (current_user.is_authenticated and current_user.is_subscribed)|tojson|default('false') }};

function startSentimentAnalysis() {
    console.log('startSentimentAnalysis called');
    
    // Clear any existing loading intervals
    if (messageRotationInterval) {
        clearInterval(messageRotationInterval);
        messageRotationInterval = null;
    }
    if (factRotationInterval) {
        clearInterval(factRotationInterval);
        factRotationInterval = null;
    }
    if (progressAnimationFrame) {
        cancelAnimationFrame(progressAnimationFrame);
        progressAnimationFrame = null;
    }
    
    // Reset progress values
    lastProgressValue = 0;
    targetProgress = 0;
    currentMessageIndex = 0;
    currentFactIndex = 0;
    
    const videoId = '{{ video_id }}';
    const section = document.getElementById('sentimentAnalysisSection');
    const progressDiv = document.getElementById('analysisProgress');
    const resultsDiv = document.getElementById('analysisResults');
    const analysisActionButton = document.getElementById('analysisActionButton');
    
    // Use total available comments from video statistics
    const totalAvailable = {{ comment_stats.total_available|default(0) }};
    const videoStatsComments = {{ (video_info.statistics.comments if video_info else 0)|default(0) }};
    const fetchedCommentsCount = {{ comment_stats.total_comments|default(0) }};
    const totalAvailableComments = totalAvailable || videoStatsComments || fetchedCommentsCount;
    const fetchedComments = {{ comment_stats.fetched_comments|default(0) }};
    
    // Get value based on current mode
    let commentsToAnalyze;
    if (currentAnalysisMode === 'instant') {
        commentsToAnalyze = parseInt(instantSlider ? instantSlider.value : 100) || 100;
        } else {
            // For backward compatibility with old button
            commentCountInput = document.getElementById('commentCountInput');
            commentsToAnalyze = parseInt(commentCountInput ? commentCountInput.value : 1000) || 1000;
    }
    let selectedPercentage = Math.round((commentsToAnalyze / totalAvailableComments) * 100);
    
    // Determine if we're in queue mode based on the current analysis mode
    const isQueueMode = currentAnalysisMode && (currentAnalysisMode === 'queue' || 
                                                currentAnalysisMode === 'pro-queue' || 
                                                currentAnalysisMode === 'all');
    
    console.log('Analysis configuration:', {
        mode: currentAnalysisMode,
        commentsToAnalyze: commentsToAnalyze,
        isQueueMode: isQueueMode,
        isAuthenticated: isAuthenticated,  // Using global
        isProUser: isProUser  // Using global
    });
    
    // Apply appropriate limits based on user status
    if (!isAuthenticated) {
        commentsToAnalyze = Math.min(commentsToAnalyze, 500);  // Non-authenticated: instant only up to 500
        commentsToAnalyze = Math.max(commentsToAnalyze, 5);
    } else if (!isProUser) {
        commentsToAnalyze = Math.min(commentsToAnalyze, 2500);  // Free users: up to 2500
        commentsToAnalyze = Math.max(commentsToAnalyze, 5);
    } else {
        // Pro users can go up to 5000
        if (currentAnalysisMode === 'all') {
            commentsToAnalyze = Math.min(totalAvailableComments, 5000);
        } else {
            commentsToAnalyze = Math.min(commentsToAnalyze, 5000);
        }
        commentsToAnalyze = Math.max(commentsToAnalyze, 5);
    }
    
    // Handle authentication for queue mode
    if (isQueueMode && !isAuthenticated) {
        // Non-authenticated user trying to queue - show login prompt
        showLoginPrompt();
        return;
    } else if (isQueueMode && !isProUser && commentsToAnalyze > 2500) {
        // Regular user trying to analyze more than 2.5k comments - show upgrade prompt
        showProUpgradePrompt();
        return;
    } else if (isQueueMode && isAuthenticated) {
        // Queue mode - create a background job
        console.log('Queueing job for', commentsToAnalyze, 'comments');
        
        // Calculate estimated time
        const estimatedMinutes = Math.round((commentsToAnalyze / 100) * 1.5 / 60);
        const timeText = estimatedMinutes > 1 ? `${estimatedMinutes} minutes` : '1 minute';
        
        // Disable button with loading state
        if (analysisActionButton) {
            analysisActionButton.disabled = true;
            analysisActionButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Queueing...';
        }
        
        fetch('/api/analyze/queue', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                video_id: videoId,
                comment_count: commentsToAnalyze,
                include_replies: false  // Never include replies
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showToast(`Analysis queued! Estimated time: ~${timeText}`, 'success');
                // Redirect to the analysis status page
                setTimeout(() => {
                    window.location.href = `/analysis/${data.job_id}`;
                }, 1500);
            } else {
                // Check for specific auth errors
                if (data.redirect_to_login) {
                    // Show the login prompt modal
                    showLoginPrompt();
                } else if (data.redirect_to_upgrade) {
                    // Show the upgrade modal
                    showProUpgradePrompt();
                } else {
                    // Show regular error
                    showToast(`Error: ${data.error}`, 'error');
                }
                
                // Re-enable button
                if (analysisActionButton) {
                    analysisActionButton.disabled = false;
                    const buttonIcon = document.getElementById('buttonIcon');
                    const buttonText = document.getElementById('buttonText');
                    if (buttonIcon) buttonIcon.textContent = 'â°';
                    if (buttonText) buttonText.textContent = 'Queue Analysis';
                }
            }
        })
        .catch(error => {
            console.error('Error queueing analysis:', error);
            
            // Check if it's an authentication error (401)
            if (error.message && error.message.includes('401')) {
                showLoginPrompt();
            } else {
                showToast('Failed to queue analysis', 'error');
            }
            
            // Re-enable button
            if (analysisActionButton) {
                analysisActionButton.disabled = false;
                const buttonIcon = document.getElementById('buttonIcon');
                const buttonText = document.getElementById('buttonText');
                if (buttonIcon) buttonIcon.textContent = 'â°';
                if (buttonText) buttonText.textContent = 'Queue Analysis';
            }
        });
        
        return;
    }
    
    // Check if we can use already loaded comments
    const usePreloaded = fetchedComments > 0 && 
                         Math.abs(commentsToAnalyze - fetchedComments) <= 5; // Allow small margin
    
    // Show section and hide results
    section.style.display = 'block';
    section.classList.add('active');
    progressDiv.style.display = 'flex';
    resultsDiv.style.display = 'none';
    
    // Initialize fun fact
    const funFactText = document.getElementById('funFactText');
    if (funFactText) {
        funFactText.textContent = funFacts[0];
    }
    
    // Disable unified button with loading text
    const loadingText = usePreloaded ? 'Loading Cached Results...' : 'Analyzing...';
    
    if (analysisActionButton) {
        analysisActionButton.disabled = true;
        analysisActionButton.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${loadingText}`;
    }
    
    // Scroll to sentiment analysis section
    section.scrollIntoView({ behavior: 'smooth', block: 'start' });
    
    // If we have preloaded comments, check for cached results first
    if (usePreloaded && analysisActionButton) {
        // Generate the expected analysis ID for cached results
        const expectedAnalysisId = `sentiment_${videoId}_${selectedPercentage}pct_${commentsToAnalyze}`;
        
        // Try to fetch cached results directly
        fetch(`/api/analyze/results/${expectedAnalysisId}`)
            .then(response => {
                // Check status code to determine what happened
                if (response.status === 202) {
                    // Analysis exists but not yet completed - wait for it
                    return response.json().then(data => {
                        console.log('Analysis in progress, waiting for completion...');
                        analysisId = expectedAnalysisId;
                        // Update progress status  
                        if (data.status) {
                            updateProgress(data.status);
                        }
                        // Start polling for completion
                        statusCheckInterval = setInterval(checkAnalysisStatus, 1000);
                        return null; // Signal that we're waiting
                    });
                } else if (response.ok) {
                    return response.json();
                } else {
                    // Handle error responses
                    return response.json().then(data => {
                        throw new Error(data.error || 'Failed to fetch results');
                    });
                }
            })
            .then(data => {
                if (data === null) {
                    // We're waiting for in-progress analysis
                    return;
                }
                if (data && data.success && data.results) {
                    // Cached results found! Display them immediately
                    analysisId = expectedAnalysisId;
                    displayResults(data.results);
                    return; // Exit early, no need to start new analysis
                } else {
                    // No cached results, proceed with analysis
                    initiateAnalysis(videoId, commentsToAnalyze, selectedPercentage);
                }
            })
            .catch(error => {
                // Error fetching cached results, proceed with analysis
                console.log('No cached results available, starting analysis:', error.message);
                initiateAnalysis(videoId, commentsToAnalyze, selectedPercentage);
            });
    } else {
        // Not using preloaded or different comment count, start fresh analysis
        initiateAnalysis(videoId, commentsToAnalyze, selectedPercentage);
    }
}

function initiateAnalysis(videoId, commentsToAnalyze, selectedPercentage) {
    // Always exclude replies
    const includeReplies = false;
    
    console.log('Initiating analysis with:', JSON.stringify({
        videoId: videoId,
        commentsToAnalyze: commentsToAnalyze,
        selectedPercentage: selectedPercentage,
        includeReplies: includeReplies
    }, null, 2));
    
    // Start analysis with selected number of comments
    fetch(`/api/analyze/sentiment/${videoId}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            max_comments: commentsToAnalyze,  // Use calculated count based on percentage
            percentage_selected: selectedPercentage,  // Send percentage for logging
            include_replies: includeReplies  // Send reply toggle state
        })
    })
    .then(response => {
        if (response.status === 507) {
            // Insufficient Storage - cache memory full
            showError('The analysis cache is currently full. Please wait a moment while we clear some space and try again.');
            // Automatically retry after 3 seconds
            setTimeout(() => {
                showError('Retrying analysis...');
                startSentimentAnalysis();
            }, 3000);
            return null;
        }
        return response.json();
    })
    .then(data => {
        if (data === null) return; // Handled above
        
        if (data.success) {
            analysisId = data.analysis_id;
            if (data.cached) {
                // If cached, fetch results immediately
                fetchAnalysisResults();
            } else {
                // Start polling for status
                statusCheckInterval = setInterval(checkAnalysisStatus, 1000);
            }
        } else {
            if (data.error && data.error.includes('memory')) {
                showError('Cache memory issue detected. Clearing space and retrying...');
                setTimeout(() => startSentimentAnalysis(), 2000);
            } else {
                showError(data.error);
            }
        }
    })
    .catch(error => {
        showError('Failed to start analysis: ' + error);
    });
}

function checkAnalysisStatus() {
    if (!analysisId) return;
    
    fetch(`/api/analyze/status/${analysisId}`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                updateProgress(data.status);
                
                if (data.status.status === 'completed') {
                    clearInterval(statusCheckInterval);
                    fetchAnalysisResults();
                } else if (data.status.status === 'error') {
                    clearInterval(statusCheckInterval);
                    showError(data.status.error);
                }
            } else if (!data.success && data.error === 'Analysis not found') {
                // Analysis was lost, restart automatically
                clearInterval(statusCheckInterval);
                console.log('Analysis not found during status check, restarting...');
                showError('Analysis data was cleared. Restarting...');
                analysisId = null;
                setTimeout(() => {
                    startSentimentAnalysis();
                }, 1500);
            }
        })
        .catch(error => {
            console.error('Status check error:', error);
        });
}

// currentAnalysisMode is already declared at line 1880, removing duplicate

// Fun loading messages
const loadingMessages = {
    fetching_comments: [
        "Reticulating comment splines...",
        "Downloading hot takes from the cloud...",
        "Harvesting fresh opinions...",
        "Summoning the comment spirits...",
        "Deploying YouTube API ninjas...",
        "Gathering digital discourse...",
        "Extracting text vibes from the matrix..."
    ],
    analyzing_sentiment: [
        "Calibrating emotional sensors...",
        "Teaching AI about human feelings...",
        "Decoding sentiment wavelengths...",
        "Consulting the vibe oracle...",
        "Computing emotional algorithms...",
        "Analyzing the mood spectrum...",
        "Processing digital emotions...",
        "Calculating happiness quotients...",
        "Measuring sentiment particles..."
    ],
    generating_summary: [
        "Crafting wisdom from chaos...",
        "Distilling comment essence...",
        "Generating insight crystals...",
        "Compiling the final verdict...",
        "Preparing your custom report...",
        "Assembling thought molecules...",
        "Weaving the narrative tapestry..."
    ]
};

const funFacts = [
    "Did you know? The average YouTube comment is 27 words long!",
    "Fun fact: 70% of YouTube comments are positive or neutral!",
    "YouTube gets over 500 hours of video uploaded every minute!",
    "The first YouTube comment ever was 'Interesting...' in 2005!",
    "Comments with emojis get 33% more engagement! ðŸ˜Š",
    "YouTube comments support over 75 languages worldwide!",
    "The most liked YouTube comment has over 4 million likes!",
    "Did you know? Comments peak within the first 2 hours of upload!",
    "YouTube's algorithm considers comment sentiment for recommendations!"
];

let messageRotationInterval = null;
let currentMessageIndex = 0;
let factRotationInterval = null;
let currentFactIndex = 0;
let lastProgressValue = 0;
let targetProgress = 0;
let progressAnimationFrame = null;

function updateProgress(status) {
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const progressStatus = document.getElementById('progressStatus');
    const progressSubStatus = document.getElementById('progressSubStatus');
    const progressDetail = document.getElementById('progressDetail');
    const funFactText = document.getElementById('funFactText');
    
    // Set target progress for smooth animation
    targetProgress = status.progress || 0;
    
    // Smooth progress bar animation
    function animateProgress() {
        if (Math.abs(lastProgressValue - targetProgress) > 0.5) {
            lastProgressValue += (targetProgress - lastProgressValue) * 0.1;
            progressBar.style.width = lastProgressValue + '%';
            progressText.textContent = Math.round(lastProgressValue) + '%';
            progressAnimationFrame = requestAnimationFrame(animateProgress);
        } else {
            lastProgressValue = targetProgress;
            progressBar.style.width = targetProgress + '%';
            progressText.textContent = Math.round(targetProgress) + '%';
        }
    }
    
    if (progressAnimationFrame) {
        cancelAnimationFrame(progressAnimationFrame);
    }
    animateProgress();
    
    // Main status messages
    let mainStatus = 'Initializing vibe check...';
    let subStatus = '';
    let messagePool = [];
    
    switch(status.status) {
        case 'fetching_comments':
            mainStatus = 'Downloading Comments';
            subStatus = loadingMessages.fetching_comments[0];
            messagePool = loadingMessages.fetching_comments;
            progressDetail.textContent = `${status.current || 0} fetched`;
            break;
        case 'using_cached':
            mainStatus = 'Loading Cached Data';
            subStatus = 'Retrieving pre-analyzed vibes...';
            progressDetail.textContent = 'Fast mode activated';
            break;
        case 'analyzing_sentiment':
            mainStatus = 'Analyzing Sentiment';
            subStatus = loadingMessages.analyzing_sentiment[0];
            messagePool = loadingMessages.analyzing_sentiment;
            progressDetail.textContent = `${status.current || 0}/${status.total || 0} comments`;
            break;
        case 'generating_summary':
            mainStatus = 'Generating Insights';
            subStatus = loadingMessages.generating_summary[0];
            messagePool = loadingMessages.generating_summary;
            progressDetail.textContent = 'Almost there!';
            break;
        case 'completed':
            mainStatus = 'âœ¨ Analysis Complete!';
            subStatus = 'Your results are ready!';
            progressDetail.textContent = '';
            // Clear intervals when complete
            if (messageRotationInterval) {
                clearInterval(messageRotationInterval);
            }
            if (factRotationInterval) {
                clearInterval(factRotationInterval);
            }
            break;
    }
    
    progressStatus.textContent = mainStatus;
    progressSubStatus.textContent = subStatus;
    
    // Start rotating messages for this status
    if (messagePool.length > 0 && status.status !== 'completed') {
        if (messageRotationInterval) {
            clearInterval(messageRotationInterval);
        }
        currentMessageIndex = 0;
        
        messageRotationInterval = setInterval(() => {
            currentMessageIndex = (currentMessageIndex + 1) % messagePool.length;
            progressSubStatus.textContent = messagePool[currentMessageIndex];
            progressSubStatus.style.animation = 'none';
            setTimeout(() => {
                progressSubStatus.style.animation = 'fadeInOut 4s ease-in-out infinite';
            }, 10);
        }, 3000);
    }
    
    // Rotate fun facts
    if (!factRotationInterval && status.status !== 'completed') {
        factRotationInterval = setInterval(() => {
            currentFactIndex = (currentFactIndex + 1) % funFacts.length;
            funFactText.style.opacity = '0';
            setTimeout(() => {
                funFactText.textContent = funFacts[currentFactIndex];
                funFactText.style.opacity = '1';
            }, 300);
        }, 5000);
    }
}

function fetchAnalysisResults() {
    if (!analysisId) return;
    
    fetch(`/api/analyze/results/${analysisId}`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                displayResults(data.results);
            } else {
                if (data.restart_needed) {
                    // Results are missing, restart the analysis
                    console.error('Results missing, restarting analysis...');
                    showError('Previous analysis expired. Starting fresh analysis...');
                    // Clear the current analysis ID and restart
                    analysisId = null;
                    setTimeout(() => {
                        startSentimentAnalysis();
                    }, 2000);
                } else if (data.error && data.error.includes('Analysis not found')) {
                    // Analysis was cleared or expired
                    showError('This analysis has expired or been cleared. Starting a new analysis...');
                    analysisId = null;
                    // Automatically restart the analysis
                    setTimeout(() => {
                        // Reset UI
                        const progressDiv = document.getElementById('analysisProgress');
                        const resultsDiv = document.getElementById('analysisResults');
                        if (progressDiv) progressDiv.style.display = 'flex';
                        if (resultsDiv) resultsDiv.style.display = 'none';
                        // Start fresh analysis
                        startSentimentAnalysis();
                    }, 1500);
                } else {
                    showError(data.error + (data.details ? ': ' + data.details : ''));
                }
            }
        })
        .catch(error => {
            showError('Failed to fetch results: ' + error);
        });
}

function retrySummary() {
    if (!analysisId) return;
    const aiSummaryEl = document.getElementById('aiSummary');
    if (aiSummaryEl) {
        aiSummaryEl.innerHTML = '<p>Retrying summary... <i class="fas fa-spinner fa-spin"></i></p>';
    }
    fetch(`/api/analyze/retry-summary/${analysisId}`, {
        method: 'POST'
    })
        .then(response => response.json())
        .then(data => {
            if (data.success && data.summary && data.summary.summary) {
                // Refresh the results to pick up the new summary
                fetchAnalysisResults();
            } else {
                if (aiSummaryEl) {
                    aiSummaryEl.innerHTML = `<p>Summary retry failed: ${data.error || 'Unknown error'}</p>`;
                }
            }
        })
        .catch(error => {
            if (aiSummaryEl) {
                aiSummaryEl.innerHTML = `<p>Summary retry failed: ${error}</p>`;
            }
        });
}

function displayResults(results) {
    console.log('displayResults called with results:', JSON.stringify(results ? Object.keys(results) : 'null', null, 2));
    if (results) {
        console.log('Results sentiment data:', JSON.stringify(results.sentiment, null, 2));
        console.log('Results summary data:', JSON.stringify(results.summary ? Object.keys(results.summary) : 'no summary', null, 2));
    }
    const progressDiv = document.getElementById('analysisProgress');
    const resultsDiv = document.getElementById('analysisResults');
    const samplesSection = document.getElementById('sampleCommentsSection');
    const startButton = document.getElementById('startSentimentAnalysis');
    const startButtonMain = document.getElementById('startSentimentAnalysisMain');
    const videoId = '{{ video_id }}';
    
    console.log('Element check:', {
        progressDiv: progressDiv ? 'found' : 'not found',
        resultsDiv: resultsDiv ? 'found' : 'not found',
        samplesSection: samplesSection ? 'found' : 'not found'
    });
    
    // Guard: ensure results have sentiment payload
    if (!results || !results.sentiment) {
        console.error('No sentiment results returned:', results);
        showError('No results returned. Please try again.');
        return;
    }

    // Update comment statistics if Pro user analyzed more comments
    if (results.updated_stats) {
        updateCommentStatistics(results.updated_stats);
    }
    
    // Hide progress, show results
    console.log('Hiding progress, showing results');
    progressDiv.style.display = 'none';
    resultsDiv.style.display = 'block';
    console.log('Results div display style:', resultsDiv.style.display);
    
    // Show sample comments section
    if (samplesSection) {
        samplesSection.style.display = 'block';
    }
    
    // Re-enable appropriate buttons
    if (startButton) {
        startButton.innerHTML = '<i class="fas fa-sync"></i> Re-analyze';
        startButton.disabled = false;
    }
    
    // Re-enable unified action button and restore appropriate text
    const analysisActionButton = document.getElementById('analysisActionButton');
    const buttonIcon = document.getElementById('buttonIcon');
    const buttonText = document.getElementById('buttonText');
    commentCountInput = document.getElementById('commentCountInput');
    
    if (analysisActionButton) {
        analysisActionButton.disabled = false;
        
        // Get current slider value to determine proper button text
        const currentValue = parseInt(commentCountInput ? commentCountInput.value : 1000) || 1000;
        
        // Update button based on current mode/value
        if (!isAuthenticated) {
            if (buttonIcon) buttonIcon.textContent = 'ðŸ§ ';
            if (buttonText) buttonText.textContent = 'Analyze Again';
        } else if (currentValue <= 2500) {
            if (buttonIcon) buttonIcon.textContent = 'ðŸ§ ';
            if (buttonText) buttonText.textContent = 'Analyze Again';
        } else if (currentValue <= 5000) {
            if (buttonIcon) buttonIcon.textContent = 'â°';
            if (buttonText) buttonText.textContent = 'Queue Again';
        } else {
            if (buttonIcon) buttonIcon.textContent = 'ðŸ‘‘';
            if (buttonText) buttonText.textContent = 'Queue Pro Analysis Again';
        }
    }
    
    // Get sentiment data
    const sentiment = results.sentiment;
    
    // Overall sentiment
    const overallEl = document.getElementById('overallSentiment');
    console.log('Overall sentiment element:', overallEl ? 'found' : 'not found');
    
    // Determine overall sentiment from distribution
    let overallSentiment = 'neutral';
    let sentimentScore = 50; // Default neutral score
    
    if (sentiment.distribution) {
        const pos = sentiment.distribution.positive || 0;
        const neg = sentiment.distribution.negative || 0;
        const neu = sentiment.distribution.neutral || 0;
        const total = pos + neg + neu;
        
        if (total > 0) {
            // Calculate sentiment score: 0 = very negative, 50 = neutral, 100 = very positive
            sentimentScore = ((pos - neg) / total * 50) + 50;
            
            // Determine overall sentiment based on distribution
            if (pos > neg && pos > neu) {
                overallSentiment = 'positive';
            } else if (neg > pos && neg > neu) {
                overallSentiment = 'negative';
            } else {
                overallSentiment = 'neutral';
            }
        }
    }
    
    const rawConf = (typeof sentiment.average_confidence === 'number') ? sentiment.average_confidence : 0;
    const confPercent = rawConf > 1 ? rawConf.toFixed(1) : (rawConf * 100).toFixed(1);
    const totalAnalyzed = sentiment.total_analyzed || (Array.isArray(sentiment.individual_results) ? sentiment.individual_results.length : 0);
    
    if (overallEl) {
        const htmlContent = `
            <strong>${overallSentiment.charAt(0).toUpperCase() + overallSentiment.slice(1)}</strong> 
            (Score: ${sentimentScore.toFixed(1)}%, 
            Confidence: ${confPercent}%)
            <br>
            <small>Analyzed ${totalAnalyzed} comments using advanced sentiment analysis</small>
        `;
        console.log('Setting overall sentiment HTML:', htmlContent);
        overallEl.innerHTML = htmlContent;
    } else {
        console.error('overallSentiment element not found!');
    }
    
    // AI Summary with Enhanced Details
    const summary = results.summary;
    const aiSummaryEl = document.getElementById('aiSummary');
    console.log('AI Summary element:', aiSummaryEl ? 'found' : 'not found');
    console.log('Summary data:', summary);
    
    // Display the summary
        if (aiSummaryEl && summary) {
            if (summary.summary) {
                aiSummaryEl.innerHTML = `<p>${summary.summary}</p>`;
                console.log('Set summary text:', summary.summary);
            } else {
                aiSummaryEl.innerHTML = '<p>Summary not available. <a href="#" id="retrySummaryLink">Try again</a></p>';
                const retryLink = document.getElementById('retrySummaryLink');
                if (retryLink) {
                    retryLink.addEventListener('click', (e) => {
                        e.preventDefault();
                        retryLink.innerHTML = 'Retrying... <i class="fas fa-spinner fa-spin"></i>';
                        retryLink.classList.add('disabled');
                        retrySummary();
                    });
                }
            }
            
            // Skip complex processing for now - just display basic summary
            /*
        // Check for any reception type sections
        const receptionTypes = [
            { marker: 'âš¡ CONTROVERSY DETECTED:', type: 'controversy', icon: 'fas fa-bolt', alertClass: 'alert-warning' },
            { marker: 'ðŸŽ† OVERWHELMINGLY POSITIVE RECEPTION:', type: 'positive', icon: 'fas fa-star', alertClass: 'alert-success' },
            { marker: 'âœ… POSITIVE RECEPTION:', type: 'positive', icon: 'fas fa-check-circle', alertClass: 'alert-success' },
            { marker: 'ðŸ¤” MIXED RECEPTION:', type: 'mixed', icon: 'fas fa-balance-scale', alertClass: 'alert-info' },
            { marker: 'âš ï¸ CRITICAL RECEPTION:', type: 'critical', icon: 'fas fa-exclamation-triangle', alertClass: 'alert-danger' }
        ];
        
        let mainInsights = insights;
        let receptionContent = null;
        let receptionType = null;
        
        // Find which reception type is in the insights
        for (const reception of receptionTypes) {
            const index = insights.indexOf(reception.marker);
            if (index > -1) {
                mainInsights = insights.substring(0, index).trim();
                const receptionSection = insights.substring(index);
                receptionType = reception;
                
                // Extract reception details
                const lines = receptionSection.split('\n');
                let receptionHtml = '';
                for (let i = 1; i < lines.length && i < 5; i++) {
                    if (lines[i].trim()) {
                        receptionHtml += `<p class="mb-2">${lines[i].trim()}</p>`;
                    }
                }
                
                // Add controversial topics with enhanced details if it's controversy type
                if (reception.type === 'controversy' && summary.controversy_analysis && 
                    summary.controversy_analysis.topics && summary.controversy_analysis.topics.length > 0) {
                    
                    // Get up to 6 controversial comments with sentiment data
                    const controversialComments = summary.controversy_analysis.topics
                        .filter(topic => topic.comment_id)
                        .slice(0, 6);
                    
                    if (controversialComments.length > 0) {
                        receptionHtml += '<div class="mt-4"><strong>Examples of divisive comments:</strong></div>';
                        controversialComments.forEach((topic, idx) => {
                            // Get sentiment data for this comment if available
                            const sentimentData = sentiment.individual_results ? 
                                sentiment.individual_results.find(r => 
                                    (r.comment_id === topic.comment_id) || 
                                    (r.text && r.text.substring(0, 50) === topic.text.substring(0, 50))
                                ) : null;
                            
                            const aiSentiment = sentimentData ? 
                                (sentimentData.predicted_sentiment || sentimentData.sentiment || 'unknown') : 
                                'unknown';
                            
                            const confidence = sentimentData && sentimentData.confidence ? 
                                (sentimentData.confidence * 100).toFixed(0) : 'N/A';
                            
                            // Determine sentiment emoji and color
                            let sentimentEmoji = 'ðŸ¤·';
                            let sentimentColor = 'secondary';
                            let sentimentLabel = 'Unknown';
                            
                            if (aiSentiment === 'positive') {
                                sentimentEmoji = 'ðŸ˜Š';
                                sentimentColor = 'success';
                                sentimentLabel = 'Positive';
                            } else if (aiSentiment === 'negative') {
                                sentimentEmoji = 'ðŸ˜”';
                                sentimentColor = 'danger';
                                sentimentLabel = 'Negative';
                            } else if (aiSentiment === 'neutral') {
                                sentimentEmoji = 'ðŸ˜';
                                sentimentColor = 'secondary';
                                sentimentLabel = 'Neutral';
                            }
                            
                            const commentSnippet = topic.text.length > 200 ? 
                                topic.text.substring(0, 200) + '...' : topic.text;
                            
                            // Determine why it's controversial
                            let controversyReason = '';
                            if (topic.controversy_score && topic.controversy_score > 0.7) {
                                controversyReason = 'This comment has highly polarized reactions.';
                            } else if (aiSentiment === 'positive' && topic.text.toLowerCase().includes('but')) {
                                controversyReason = 'Mixed signals: Contains both praise and criticism.';
                            } else if (aiSentiment === 'negative') {
                                controversyReason = 'Critical viewpoint that sparked debate.';
                            } else if (aiSentiment === 'neutral') {
                                controversyReason = 'Balanced perspective that divided opinions.';
                            } else {
                                controversyReason = 'This comment generated significant discussion.';
                            }
                            
                            // Set colors based on sentiment
                            let badgeStyle = '';
                            if (aiSentiment === 'positive') {
                                badgeStyle = 'background: #28a745; color: white;';
                            } else if (aiSentiment === 'negative') {
                                badgeStyle = 'background: #dc3545; color: white;';
                            } else if (aiSentiment === 'neutral') {
                                badgeStyle = 'background: #6c757d; color: white;';
                            } else {
                                badgeStyle = 'background: #6c757d; color: white;';
                            }
                            
                            receptionHtml += `
                                <div class="mt-3 p-3 border rounded" style="background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-left: 4px solid var(--bs-${sentimentColor}) !important;">
                                    <div class="d-flex justify-content-between align-items-start mb-2">
                                        <span class="badge" style="${badgeStyle}">
                                            ${sentimentEmoji} AI: ${sentimentLabel} (${confidence}% confident)
                                        </span>
                                        <small class="text-muted">#${idx + 1}</small>
                                    </div>
                                    <p class="mb-2" style="font-style: italic; color: #495057;">
                                        "${commentSnippet}"
                                    </p>
                                    <div class="alert alert-sm alert-info py-1 px-2 mb-0" style="font-size: 0.85rem;">
                                        <i class="fas fa-info-circle"></i> <strong>Why controversial:</strong> ${controversyReason}
                                    </div>
                                    ${topic.replies_count ? `
                                        <small class="text-muted mt-2 d-block">
                                            <i class="fas fa-comments"></i> Generated ${topic.replies_count} replies
                                        </small>
                                    ` : ''}
                                </div>
                            `;
                        });
                    }
                }
                
                if (receptionHtml) {
                    // Create reception alert box with appropriate styling
                    const heading = reception.marker.replace(/[:]/g, '').replace(/[\u{1F300}-\u{1F9FF}]/gu, '').trim();
                    receptionContent = `
                        <div class="alert ${reception.alertClass} mb-4">
                            <h5 class="alert-heading"><i class="${reception.icon}"></i> ${heading}</h5>
                            ${receptionHtml}
                        </div>
                    `;
                }
                break;
            }
        }
        
        // Display main insights
        aiSummaryEl.innerHTML = formatEnhancedSummary(mainInsights);

        // Append Most Mentioned Concepts box (green) using available data
        const conceptsHTML = buildMostMentionedConceptsHTML(summary);
        if (conceptsHTML) {
            aiSummaryEl.innerHTML += conceptsHTML;
        }
        
            // Add reception box after main summary if it exists
            if (receptionContent) {
                aiSummaryEl.innerHTML += receptionContent;
            }
        }
        */
    }
    
    // Create charts (with delay to ensure elements are visible and properly sized)
    console.log('Attempting to create charts...');
    setTimeout(() => {
        try {
            console.log('Creating sentiment pie chart...');
            createSentimentPieChart(sentiment);
        } catch (error) {
            console.error('Error creating pie chart:', error);
        }
        
        try {
            console.log('Creating timeline chart...');
            console.log('Timeline data:', results.timeline);
            
            // Use timeline data if available, otherwise create from individual results
            let timelineData = results.timeline;
            
            // If no timeline data, try to create it from individual results
            if (!timelineData || timelineData.length === 0) {
                console.log('No timeline data provided, generating from individual results...');
                if (sentiment.individual_results && sentiment.individual_results.length > 0) {
                    timelineData = sentiment.individual_results.map((item, index) => ({
                        sentiment: item.predicted_sentiment || item.sentiment || 'neutral',
                        score: item.sentiment_scores || {
                            positive: item.predicted_sentiment === 'positive' ? 0.8 : 0.1,
                            neutral: item.predicted_sentiment === 'neutral' ? 0.8 : 0.1,
                            negative: item.predicted_sentiment === 'negative' ? 0.8 : 0.1
                        },
                        text_preview: (item.text || '').substring(0, 100),
                        index: index
                    }));
                    console.log('Generated timeline data from individual results:', timelineData.length, 'items');
                }
            }
            
            if (timelineData && timelineData.length > 0) {
                createTimelineChart(timelineData);
            } else {
                console.log('No timeline data available to display');
                // Hide the timeline chart section if no data
                const timelineCard = document.querySelector('#sentimentTimelineChart').closest('.card');
                if (timelineCard) {
                    timelineCard.style.display = 'none';
                }
            }
        } catch (error) {
            console.error('Error creating timeline chart:', error);
        }
    }, 500);
    
    // Display sample comments
    console.log('Displaying sample comments...');
    try {
        displaySampleComments(sentiment.individual_results);
    } catch (error) {
        console.error('Error displaying sample comments:', error);
    }
}

function createSentimentPieChart(sentiment) {
    try {
        console.log('Creating sentiment pie chart with data:', sentiment);
        const canvas = document.getElementById('sentimentPieChart');
        if (!canvas) {
            console.error('Canvas element sentimentPieChart not found');
            return;
        }
        
        const ctx = canvas.getContext('2d');
        if (!ctx) {
            console.error('Could not get 2D context from canvas');
            return;
        }
        
        if (charts.pie) charts.pie.destroy();
        
        // Use counts from either sentiment_counts or distribution
        const counts = (sentiment.sentiment_counts || sentiment.distribution || {positive: 0, neutral: 0, negative: 0});
        console.log('Using sentiment counts:', counts);
        
        charts.pie = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: ['Positive', 'Neutral', 'Negative'],
                datasets: [{
                    data: [
                        (counts.positive || 0),
                        (counts.neutral || 0),
                        (counts.negative || 0)
                    ],
                    backgroundColor: [
                        // Positive: match the green background used by Most Mentioned Concepts (Bootstrap alert-success bg)
                        'rgba(209, 231, 221, 0.9)',
                        // Neutral: lighter gray
                        'rgba(206, 212, 218, 0.9)',
                        // Negative: complementary red to the green above
                        'rgba(227, 93, 106, 0.85)'
                    ],
                    borderColor: [
                        // Positive border: Bootstrap success
                        'rgba(25, 135, 84, 1)',
                        'rgba(160, 165, 170, 1)',
                        // Negative border: deeper complementary red
                        'rgba(176, 42, 55, 1)'
                    ],
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom',
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.parsed || 0;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(1);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    } catch (error) {
        console.error('Error creating pie chart:', error);
    }
}

function buildMostMentionedConceptsHTML(summary) {
    try {
        if (!summary) return '';

        // Prefer social_media_themes if available
        let items = [];
        if (summary.social_media_themes && Array.isArray(summary.social_media_themes.themes)) {
            items = summary.social_media_themes.themes.map(t => ({
                word: t.word || t.term || t.key || '',
                percent: typeof t.percentage === 'number' ? t.percentage : (typeof t.score === 'number' ? t.score * 100 : 0)
            }));
        } else if (Array.isArray(summary.intelligent_themes)) {
            // intelligent_themes is typically [ [word, score], ... ]
            items = summary.intelligent_themes.map(t => ({
                word: Array.isArray(t) ? t[0] : (t.word || t || ''),
                percent: Array.isArray(t) && typeof t[1] === 'number' ? t[1] * 100 : (typeof t.score === 'number' ? t.score * 100 : 0)
            }));
        }

        // Clean and sort
        items = items
            .filter(i => i.word && typeof i.percent === 'number')
            .sort((a, b) => b.percent - a.percent)
            .slice(0, 10);

        if (items.length === 0) return '';

        // Build green alert styled like Sentiment Landscape
        let html = '';
        html += '<div class="alert alert-success mb-3">';
        html += '<h6 class="alert-heading"><i class="fas fa-tags"></i> Most Mentioned Concepts</h6>';
        html += '<ul class="mb-0">';
        items.forEach((it, idx) => {
            const pct = Math.round(it.percent);
            html += `<li class="small">${idx + 1}. <strong>${it.word}</strong> â€” ${pct}%</li>`;
        });
        html += '</ul>';
        html += '</div>';
        return html;
    } catch (e) {
        console.error('Error building Most Mentioned Concepts:', e);
        return '';
    }
}

function createTimelineChart(timeline) {
    try {
        console.log('Creating timeline chart with data:', timeline ? timeline.length : 'no timeline');
        const canvas = document.getElementById('sentimentTimelineChart');
        if (!canvas) {
            console.error('Canvas element sentimentTimelineChart not found');
            return;
        }
        
        const ctx = canvas.getContext('2d');
        if (!ctx) {
            console.error('Could not get 2D context from timeline canvas');
            return;
        }
        
        if (charts.timeline) charts.timeline.destroy();
        
        if (!timeline || timeline.length === 0) {
            console.log('No timeline data available');
            // Show a message instead of an empty chart
            const timelineCard = canvas.closest('.card');
            if (timelineCard) {
                const cardBody = timelineCard.querySelector('.card-body');
                if (cardBody) {
                    cardBody.innerHTML = '<p class="text-muted text-center py-3">Timeline data not available for this analysis</p>';
                }
            }
            return;
        }
        
        // Process timeline data with smoothing and grouping
        const labels = [];
        const positiveData = [];
        const neutralData = [];
        const negativeData = [];
        
        console.log('Processing timeline data, sample item:', timeline[0]);
        
        // Group comments for smoother visualization
        const groupSize = Math.max(1, Math.ceil(timeline.length / 20)); // Create ~20 groups max
        const groups = [];
        
        for (let i = 0; i < timeline.length; i += groupSize) {
            const group = timeline.slice(i, Math.min(i + groupSize, timeline.length));
            
            // Calculate average sentiment for the group
            let avgPositive = 0, avgNeutral = 0, avgNegative = 0;
            let validItems = 0;
            
            group.forEach(item => {
                const sc = item.score || item.sentiment_scores || {};
                
                // Handle case where scores might not exist - use sentiment label as fallback
                if (Object.keys(sc).length === 0) {
                    const sentiment = item.sentiment || item.predicted_sentiment || 'neutral';
                    if (sentiment === 'positive') {
                        sc.positive = 0.8;
                        sc.neutral = 0.15;
                        sc.negative = 0.05;
                    } else if (sentiment === 'negative') {
                        sc.positive = 0.05;
                        sc.neutral = 0.15;
                        sc.negative = 0.8;
                    } else {
                        sc.positive = 0.1;
                        sc.neutral = 0.8;
                        sc.negative = 0.1;
                    }
                }
                
                avgPositive += (sc.positive || 0);
                avgNeutral += (sc.neutral || 0);
                avgNegative += (sc.negative || 0);
                validItems++;
            });
            
            const groupCount = validItems || 1;
            groups.push({
                positive: (avgPositive / groupCount) * 100,
                neutral: (avgNeutral / groupCount) * 100,
                negative: (avgNegative / groupCount) * 100,
                index: i
            });
        }
        
        console.log('Created', groups.length, 'groups from timeline data');
        
        // Create labels and data from groups
        groups.forEach((group, idx) => {
            const position = (group.index / timeline.length) * 100;
            
            if (idx === 0) {
                labels.push('Early');
            } else if (idx === groups.length - 1) {
                labels.push('Recent');
            } else if (Math.abs(position - 25) < 5) {
                labels.push('25%');
            } else if (Math.abs(position - 50) < 5) {
                labels.push('Midpoint');
            } else if (Math.abs(position - 75) < 5) {
                labels.push('75%');
            } else {
                labels.push(`${Math.round(position)}%`);
            }
            
            positiveData.push(group.positive);
            neutralData.push(group.neutral);
            negativeData.push(group.negative);
        });
        
        charts.timeline = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    {
label: 'Positive',
                        data: positiveData,
                        borderColor: 'rgba(25, 135, 84, 1)',
                        backgroundColor: 'rgba(209, 231, 221, 0.35)',
                        tension: 0.4
                    },
                    {
label: 'Neutral',
                        data: neutralData,
                        borderColor: 'rgba(160, 165, 170, 1)',
                        backgroundColor: 'rgba(206, 212, 218, 0.35)',
                        tension: 0.4
                    },
                    {
label: 'Negative',
                        data: negativeData,
                        borderColor: 'rgba(176, 42, 55, 1)',
                        backgroundColor: 'rgba(227, 93, 106, 0.25)',
                        tension: 0.4
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Comment Timeline (Early â†’ Recent)',
                            font: {
                                size: 12
                            }
                        },
                        ticks: {
                            autoSkip: false,
                            maxRotation: 0,
                            font: {
                                size: 11
                            }
                        }
                    },
                    y: {
                        beginAtZero: true,
                        max: 100,
                        title: {
                            display: true,
                            text: 'Sentiment Score',
                            font: {
                                size: 12
                            }
                        },
                        ticks: {
                            callback: function(value) {
                                return value + '%';
                            }
                        }
                    }
                },
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    legend: {
                        position: 'bottom',
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            title: function(tooltipItems) {
                                const index = tooltipItems[0].dataIndex;
                                const total = tooltipItems[0].chart.data.labels.length;
                                const position = tooltipItems[0].label || `Position ${index + 1}/${total}`;
                                return `Timeline: ${position}`;
                            },
                            label: function(context) {
                                const label = context.dataset.label;
                                const value = context.parsed.y.toFixed(1);
                                const emoji = label === 'Positive' ? 'ðŸ˜Š' : label === 'Negative' ? 'ðŸ˜”' : 'ðŸ˜';
                                return `${emoji} ${label}: ${value}%`;
                            },
                            afterLabel: function(context) {
                                // Show dominant sentiment at this point
                                if (context.datasetIndex === 0) { // Only show once
                                    const datasets = context.chart.data.datasets;
                                    const index = context.dataIndex;
                                    const positive = datasets[0].data[index];
                                    const neutral = datasets[1].data[index];
                                    const negative = datasets[2].data[index];
                                    
                                    let dominant = 'Neutral';
                                    if (positive > neutral && positive > negative) dominant = 'Positive';
                                    else if (negative > neutral && negative > positive) dominant = 'Negative';
                                    
                                    return `\nDominant: ${dominant}`;
                                }
                            }
                        }
                    }
                }
            }
        });
    } catch (error) {
        console.error('Error creating timeline chart:', error);
    }
}


function displaySampleComments(results) {
    try {
        if (!results || !Array.isArray(results)) {
            console.error('Invalid results data for sample comments:', results);
            return;
        }
        
        const videoId = '{{ video_id }}';
        const positive = [];
        const neutral = [];
        const negative = [];
        
        // Categorize ALL comments (not just 3)
        results.forEach(result => {
            const comment = {
                text: result.text,
                confidence: ((typeof result.confidence === 'number' ? (result.confidence > 1 ? result.confidence : result.confidence * 100) : 0)).toFixed(1),
                commentId: (result.commentId || result.comment_id || null),
                author: result.author || 'Anonymous'
            };
            
            // Check for both 'predicted_sentiment' and 'sentiment' fields for compatibility
            const sentiment = result.predicted_sentiment || result.sentiment;
            
            if (sentiment === 'positive') {
                positive.push(comment);
            } else if (sentiment === 'neutral') {
                neutral.push(comment);
            } else if (sentiment === 'negative') {
                negative.push(comment);
            }
        });
        
        // Sort by confidence (highest first)
        positive.sort((a, b) => parseFloat(b.confidence) - parseFloat(a.confidence));
        neutral.sort((a, b) => parseFloat(b.confidence) - parseFloat(a.confidence));
        negative.sort((a, b) => parseFloat(b.confidence) - parseFloat(a.confidence));
        
        // Update counts
        document.getElementById('positiveCount').textContent = positive.length;
        document.getElementById('neutralCount').textContent = neutral.length;
        document.getElementById('negativeCount').textContent = negative.length;
        
        // Display samples with enhanced formatting
        const displaySamples = (samples, elementId, sentimentClass) => {
            const el = document.getElementById(elementId);
            if (samples.length === 0) {
                el.innerHTML = '<p class="text-muted text-center py-3">No samples available</p>';
            } else {
                // Show up to 50 comments per category for better overview
                const displayLimit = Math.min(samples.length, 50);
                const truncateText = (text, maxLength = 300) => {
                    if (text.length <= maxLength) return text;
                    return text.substring(0, maxLength) + '...';
                };
                
                el.innerHTML = samples.slice(0, displayLimit).map((s, index) => {
                    const truncated = truncateText(s.text);
                    const confidenceColor = parseFloat(s.confidence) >= 80 ? 'success' : 
                                           parseFloat(s.confidence) >= 60 ? 'warning' : 'secondary';
                    const commentId = `comment-${sentimentClass}-${index}`;
                    
                    return `
                        <div class="comment-sample-item ${sentimentClass}" id="${commentId}" data-comment-index="${index}">
                            <div class="comment-sample-text">
                                ${escapeHtml(truncated)}
                            </div>
                            <div class="comment-sample-meta">
                                <span class="text-muted">
                                    <i class="fas fa-user-circle"></i> ${escapeHtml((s.author || 'Anonymous').substring(0, 20))}
                                </span>
                                <span class="confidence-badge bg-${confidenceColor}">
                                    ${s.confidence}%
                                </span>
                            </div>
                            <div class="feedback-buttons">
                                <span class="text-muted" style="font-size: 0.7rem; margin-right: 8px;">AI thinks:</span>
                                <button class="feedback-btn positive ${sentimentClass === 'positive' ? 'current-sentiment' : ''}" 
                                        ${sentimentClass === 'positive' ? 'disabled' : ''}
                                        onclick="submitFeedback('${commentId}', '${sentimentClass}', 'positive', ${index})">
                                    ðŸ‘ Positive
                                </button>
                                <button class="feedback-btn neutral ${sentimentClass === 'neutral' ? 'current-sentiment' : ''}" 
                                        ${sentimentClass === 'neutral' ? 'disabled' : ''}
                                        onclick="submitFeedback('${commentId}', '${sentimentClass}', 'neutral', ${index})">
                                    ðŸ‘ Neutral
                                </button>
                                <button class="feedback-btn negative ${sentimentClass === 'negative' ? 'current-sentiment' : ''}" 
                                        ${sentimentClass === 'negative' ? 'disabled' : ''}
                                        onclick="submitFeedback('${commentId}', '${sentimentClass}', 'negative', ${index})">
                                    ðŸ‘Ž Negative
                                </button>
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Add a note if there are more comments
                if (samples.length > displayLimit) {
                    el.innerHTML += `
                        <div class="text-center text-muted py-2">
                            <small><i class="fas fa-info-circle"></i> Showing ${displayLimit} of ${samples.length} ${sentimentClass} comments</small>
                        </div>
                    `;
                }
            }
        };
        
        // Helper function to escape HTML
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
        
        // Store comment data globally for feedback
        commentData.positive = positive;
        commentData.neutral = neutral;
        commentData.negative = negative;
        
        displaySamples(positive, 'positiveSamples', 'positive');
        displaySamples(neutral, 'neutralSamples', 'neutral');
        displaySamples(negative, 'negativeSamples', 'negative');
        
        // Apply stored corrections after comments are displayed
        setTimeout(() => {
            applyStoredCorrections();
        }, 100);
        
    } catch (error) {
        console.error('Error displaying sample comments:', error);
    }
}

// Submit sentiment feedback
async function submitFeedback(commentId, predictedSentiment, correctedSentiment, commentIndex) {
    // Don't submit if it's the same sentiment
    if (predictedSentiment === correctedSentiment) {
        return;
    }
    
    const videoId = '{{ video_id }}';
    const commentElement = document.getElementById(commentId);
    
    // Get the comment data
    const commentObj = commentData[predictedSentiment][commentIndex];
    if (!commentObj) {
        console.error('Comment data not found');
        return;
    }
    
    try {
        // Disable all buttons in this comment
        const buttons = commentElement.querySelectorAll('.feedback-btn');
        buttons.forEach(btn => btn.disabled = true);
        
        // Send feedback to server
        const response = await fetch('/api/sentiment-feedback', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                video_id: videoId,
                comment_id: commentObj.commentId,
                comment_text: commentObj.text,
                comment_author: commentObj.author,
                predicted_sentiment: predictedSentiment,
                corrected_sentiment: correctedSentiment,
                confidence_score: parseFloat(commentObj.confidence) / 100
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Show thank you message
            showToast(data.message || 'Thank you for your feedback!', 'success', 3000);
            
            // Apply manual correction UI instead of removing the comment
            applyManualCorrectionUI(commentElement, predictedSentiment, correctedSentiment);
            
            // Store the correction in session storage for persistence
            storeCorrectionLocally(commentObj.text, predictedSentiment, correctedSentiment);
            
        } else {
            // Re-enable buttons on error
            buttons.forEach(btn => btn.disabled = false);
            if (data.error && data.error.includes('already submitted')) {
                showToast('You\'ve already provided feedback for this comment', 'info');
            } else {
                showToast(data.error || 'Failed to submit feedback', 'warning');
            }
        }
        
    } catch (error) {
        console.error('Error submitting feedback:', error);
        showToast('Failed to submit feedback. Please try again.', 'danger');
        
        // Re-enable buttons
        const buttons = commentElement.querySelectorAll('.feedback-btn');
        buttons.forEach(btn => btn.disabled = false);
    }
}

// Apply manual correction UI to a comment
function applyManualCorrectionUI(commentElement, originalSentiment, correctedSentiment) {
    // Add manually corrected class
    commentElement.classList.add('manually-corrected');
    
    // Add correction badge
    if (!commentElement.querySelector('.manual-correction-badge')) {
        const badge = document.createElement('div');
        badge.className = 'manual-correction-badge';
        badge.innerHTML = '<i class="fas fa-user-check"></i> Manually Corrected';
        commentElement.appendChild(badge);
    }
    
    // Update feedback buttons
    const buttons = commentElement.querySelectorAll('.feedback-btn');
    buttons.forEach(btn => {
        btn.disabled = true;
        btn.classList.remove('current-sentiment', 'highlighted-correction', 'disabled-original');
        
        // Check which button corresponds to what sentiment
        if (btn.classList.contains(originalSentiment)) {
            // This was the original (wrong) prediction
            btn.classList.add('disabled-original');
        } else if (btn.classList.contains(correctedSentiment)) {
            // This is the user's correction
            btn.classList.add('highlighted-correction');
        }
    });
    
    // Add correction info if not already present
    if (!commentElement.querySelector('.correction-info')) {
        const correctionInfo = document.createElement('div');
        correctionInfo.className = 'correction-info';
        correctionInfo.innerHTML = `
            <i class="fas fa-info-circle"></i>
            <span class="original-prediction">AI predicted: ${capitalizeFirst(originalSentiment)}</span>
            <span class="user-correction">â†’ You corrected to: ${capitalizeFirst(correctedSentiment)}</span>
        `;
        commentElement.appendChild(correctionInfo);
    }
}

// Store correction locally for persistence
function storeCorrectionLocally(commentText, originalSentiment, correctedSentiment) {
    const videoId = '{{ video_id }}';
    const storageKey = `sentiment_corrections_${videoId}`;
    
    // Get existing corrections
    let corrections = JSON.parse(localStorage.getItem(storageKey) || '{}');
    
    // Store the correction using comment text as key (truncated for efficiency)
    const commentKey = commentText.substring(0, 100);
    corrections[commentKey] = {
        original: originalSentiment,
        corrected: correctedSentiment,
        timestamp: new Date().toISOString()
    };
    
    // Save back to localStorage
    localStorage.setItem(storageKey, JSON.stringify(corrections));
}

// Helper function to capitalize first letter
function capitalizeFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}


function showError(error) {
    const progressDiv = document.getElementById('analysisProgress');
    const startButton = document.getElementById('startSentimentAnalysis');
    const startButtonMain = document.getElementById('startSentimentAnalysisMain');
    
    // Clear any loading intervals
    if (messageRotationInterval) {
        clearInterval(messageRotationInterval);
        messageRotationInterval = null;
    }
    if (factRotationInterval) {
        clearInterval(factRotationInterval);
        factRotationInterval = null;
    }
    if (progressAnimationFrame) {
        cancelAnimationFrame(progressAnimationFrame);
        progressAnimationFrame = null;
    }
    
    // Parse and improve error messages
    let errorTitle = "Oops! Something went wrong";
    let errorMessage = error;
    let errorIcon = "fas fa-exclamation-triangle";
    let suggestions = [];
    
    // Handle specific error patterns
    if (error.includes("futures unfinished") || error.includes("timeout")) {
        errorTitle = "Analysis Timeout";
        errorIcon = "fas fa-clock";
        errorMessage = "The analysis is taking longer than expected. This usually happens when processing many comments.";
        suggestions = [
            "Try analyzing fewer comments (reduce the slider value)",
            "Wait a moment for the service to recover",
            "If the problem persists, try again in a few minutes"
        ];
    } else if (error.includes("memory") || error.includes("cache")) {
        errorTitle = "Service Temporarily Busy";
        errorIcon = "fas fa-server";
        errorMessage = "Our servers are experiencing high demand right now.";
        suggestions = [
            "Please wait a moment and try again",
            "Consider analyzing fewer comments",
            "Try during off-peak hours for better performance"
        ];
    } else if (error.includes("not found")) {
        errorTitle = "Analysis Not Found";
        errorIcon = "fas fa-search";
        errorMessage = "The analysis results couldn't be found. They may have expired.";
        suggestions = [
            "Start a fresh analysis",
            "Make sure you haven't waited too long"
        ];
    } else if (error.includes("network") || error.includes("fetch")) {
        errorTitle = "Connection Issue";
        errorIcon = "fas fa-wifi";
        errorMessage = "There was a problem connecting to our analysis service.";
        suggestions = [
            "Check your internet connection",
            "Refresh the page and try again",
            "Disable any ad blockers or VPNs that might interfere"
        ];
    } else if (error.includes("high load") || error.includes("service")) {
        errorTitle = "Service Under Load";
        errorIcon = "fas fa-chart-line";
        errorMessage = "Our sentiment analysis service is experiencing high demand.";
        suggestions = [
            "Try with a smaller number of comments",
            "Wait a few minutes before retrying",
            "Consider using the queue option if available"
        ];
    }
    
    // Build suggestions HTML
    let suggestionsHtml = '';
    if (suggestions.length > 0) {
        suggestionsHtml = `
            <div class="mt-3">
                <h6 class="font-weight-bold">What you can try:</h6>
                <ul class="mb-0">
                    ${suggestions.map(s => `<li>${s}</li>`).join('')}
                </ul>
            </div>
        `;
    }
    
    progressDiv.innerHTML = `
        <div class="error-container animated fadeIn">
            <div class="alert alert-danger border-0 shadow-sm" style="border-radius: 12px; background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);">
                <div class="d-flex align-items-start">
                    <div class="error-icon-wrapper mr-3" style="font-size: 2rem; color: #dc2626;">
                        <i class="${errorIcon}"></i>
                    </div>
                    <div class="flex-grow-1">
                        <h5 class="alert-heading mb-2" style="color: #991b1b;">${errorTitle}</h5>
                        <p class="mb-0" style="color: #7f1d1d;">${errorMessage}</p>
                        ${suggestionsHtml}
                        
                        <!-- Debug info (hidden by default) -->
                        <details class="mt-3">
                            <summary style="cursor: pointer; color: #991b1b; font-size: 0.85rem;">
                                <i class="fas fa-bug"></i> Technical details
                            </summary>
                            <pre class="mt-2 p-2 bg-white rounded" style="font-size: 0.75rem; color: #6b7280; max-height: 100px; overflow-y: auto;">${error}</pre>
                        </details>
                    </div>
                </div>
            </div>
            
            <!-- Retry button with animation -->
            <div class="text-center mt-3">
                <button class="btn btn-lg" onclick="location.reload()" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 25px; padding: 12px 30px; border: none; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); transition: all 0.3s;" 
                        onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.5)'" 
                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(102, 126, 234, 0.4)'">
                    <i class="fas fa-redo mr-2"></i> Refresh & Try Again
                </button>
            </div>
        </div>
    `;
    
    // Re-enable both buttons
    if (startButton) {
        startButton.innerHTML = '<i class="fas fa-brain"></i> Retry Analysis';
        startButton.disabled = false;
    }
    if (startButtonMain) {
        startButtonMain.innerHTML = '<i class="fas fa-brain"></i> Retry Analysis';
        startButtonMain.disabled = false;
    }
    
    if (statusCheckInterval) {
        clearInterval(statusCheckInterval);
    }
}

// Authentication prompt functions for slider
function showLoginPrompt() {
    // Create modal or use existing modal structure
    const modalHtml = `
        <div class="modal fade" id="loginPromptModal" tabindex="-1" role="dialog" aria-labelledby="loginPromptModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-dialog-centered" role="document">
                <div class="modal-content" style="border-radius: 15px; border: none; box-shadow: 0 10px 30px rgba(0,0,0,0.2);">
                    <div class="modal-header" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 15px 15px 0 0;">
                        <h5 class="modal-title" id="loginPromptModalLabel">
                            <i class="fas fa-sign-in-alt mr-2"></i>Sign In Required
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" style="filter: brightness(0) invert(1); opacity: 0.8;"></button>
                    </div>
                    <div class="modal-body text-center" style="padding: 2rem;">
                        <div class="mb-3">
                            <i class="fas fa-lock" style="font-size: 3rem; color: #667eea; opacity: 0.7;"></i>
                        </div>
                        <h5 class="mb-3">Want to analyze more comments?</h5>
                        <p class="text-muted mb-4">Sign in to queue analysis jobs and analyze up to 2,500 comments!</p>
                        <div class="mb-3">
                            <div class="alert alert-info" style="border-radius: 10px;">
                                <strong>Free Account Benefits:</strong><br>
                                <small>
                                    âœ“ Analyze up to 2,500 comments<br>
                                    âœ“ Queue background jobs<br>
                                    âœ“ Save analysis history<br>
                                    âœ“ Export results
                                </small>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer" style="border-top: none; padding: 0 2rem 2rem 2rem;">
                        <a href="{{ url_for('auth.login') }}" class="btn btn-primary btn-lg" style="border-radius: 25px; width: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none;">
                            <i class="fas fa-sign-in-alt mr-2"></i>Sign In for Free Analysis
                        </a>
                        <div class="text-center mt-2">
                            <small class="text-muted">
                                Don't have an account? 
                                <a href="{{ url_for('auth.register') }}" class="text-primary">Create one free</a>
                            </small>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Remove existing modal if any
    const existingModal = document.getElementById('loginPromptModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    // Add modal to page
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    // Show modal using Bootstrap 5
    const loginModal = new bootstrap.Modal(document.getElementById('loginPromptModal'));
    loginModal.show();
}

function showProUpgradePrompt() {
    // Create modal for Pro upgrade
    const modalHtml = `
        <div class="modal fade" id="proUpgradePromptModal" tabindex="-1" role="dialog" aria-labelledby="proUpgradePromptModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-dialog-centered" role="document">
                <div class="modal-content" style="border-radius: 15px; border: none; box-shadow: 0 10px 30px rgba(0,0,0,0.2);">
                    <div class="modal-header" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; border-radius: 15px 15px 0 0;">
                        <h5 class="modal-title" id="proUpgradePromptModalLabel">
                            <i class="fas fa-crown mr-2"></i>Upgrade to Pro
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" style="filter: brightness(0) invert(1); opacity: 0.8;"></button>
                    </div>
                    <div class="modal-body text-center" style="padding: 2rem;">
                        <div class="mb-3">
                            <i class="fas fa-star" style="font-size: 3rem; color: #f59e0b;"></i>
                        </div>
                        <h5 class="mb-3">Unlock Advanced Analysis</h5>
                        <p class="text-muted mb-4">Upgrade to Pro to analyze up to 5,000 comments!</p>
                        <div class="mb-3">
                            <div class="alert alert-warning" style="border-radius: 10px; background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border: none;">
                                <strong>Pro Account Benefits:</strong><br>
                                <small style="color: #92400e;">
                                    âœ“ Analyze up to 5,000 comments<br>
                                    âœ“ Process entire videos<br>
                                    âœ“ Advanced filtering options<br>
                                    âœ“ Priority processing<br>
                                    âœ“ Detailed analytics reports
                                </small>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer" style="border-top: none; padding: 0 2rem 2rem 2rem;">
                        <a href="{{ url_for('auth.subscribe') }}" class="btn btn-warning btn-lg" style="border-radius: 25px; width: 100%; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); border: none; color: white;">
                            <i class="fas fa-crown mr-2"></i>Upgrade to Pro
                        </a>
                        <div class="text-center mt-2">
                            <small class="text-muted">
                                <a href="#" class="text-warning" data-dismiss="modal">Maybe later</a>
                            </small>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Remove existing modal if any
    const existingModal = document.getElementById('proUpgradePromptModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    // Add modal to page
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    // Show modal using Bootstrap 5
    const proModal = new bootstrap.Modal(document.getElementById('proUpgradePromptModal'));
    proModal.show();
    $('#proUpgradePromptModal').modal('show');
}
</script>
{% endblock %}
