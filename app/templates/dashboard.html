{% extends "base.html" %}
{% block title %}Dashboard - VibeCheckAI{% endblock %}
{% block extra_css %}
<style>
  /* Override main container for full-width dashboard */
  main.container {
    max-width: 100%;
    padding: 0;
    margin: 0;
  }
  
  .dashboard-page {
    background: transparent;
  }
  
  .dashboard-page > .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem 1rem;
  }
  
  /* Override vibe-card to remove gray background */
  .vibe-card.dashboard-card {
    background: transparent !important;
    box-shadow: none !important;
    padding: 0 !important;
  }
  
  /* Inner card with actual styling */
  .dashboard-inner-card {
    transition: transform 0.2s;
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
    overflow: hidden;
    padding: 0;
  }
  .dashboard-inner-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
  }
  
  /* Fix card-header-vibe to eliminate white corners */
  .dashboard-inner-card .card-header-vibe {
    margin: 0 !important;
    border-radius: 12px 12px 0 0 !important;
  }
  
  /* Add padding back to card body */
  .dashboard-inner-card .card-body {
    padding: 40px;
  }
  }
  
  /* Progress container matching analyze page */
  .progress-container {
    min-height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  /* Pulse animation for buttons */
  .pulse-animation {
    animation: pulse 2s infinite;
  }
  
  @keyframes pulse {
    0% {
      transform: scale(1);
      box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.7);
    }
    70% {
      transform: scale(1.05);
      box-shadow: 0 0 0 10px rgba(0, 123, 255, 0);
    }
    100% {
      transform: scale(1);
      box-shadow: 0 0 0 0 rgba(0, 123, 255, 0);
    }
  }
  
  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  @keyframes fadeOut {
    from {
      opacity: 1;
      transform: translateX(0);
    }
    to {
      opacity: 0;
      transform: translateX(20px);
    }
  }
  
  /* Updated badge animation */
  .updated-badge {
    animation: fadeIn 0.5s ease-in-out;
  }
  
  /* Stats card styling from analyze page */
  .stats-card {
    padding: 0.75rem;
    background: #f8f9fa;
    border-radius: 8px;
    transition: all 0.3s ease;
  }
  
  .stats-card:hover {
    background: #e9ecef;
    transform: translateY(-2px);
  }
  
  .stats-value {
    font-size: 1.5rem;
    font-weight: bold;
    line-height: 1;
    margin-bottom: 0.25rem;
    white-space: nowrap;
  }
  
  .stats-value.updated {
    animation: pulse 1s ease-in-out;
    color: #10b981 !important;
    transition: color 0.3s ease;
  }
  
  .stats-label {
    font-size: 0.875rem;
    color: #6c757d;
    margin-bottom: 0;
    white-space: nowrap;
  }
  
  .stats-icon {
    font-size: 0.75rem;
    margin-right: 0.25rem;
  }
  
  /* Video list styling */
  .video-list {
    max-height: 60vh;
    overflow-y: auto;
    padding: 0.5rem;
    padding-bottom: 1rem; /* Extra padding to prevent last item cutoff */
    margin-bottom: 0.5rem;
  }
  
  .video-item {
    background: white;
    border: 2px solid #e9ecef;
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    position: relative;
  }
  
  .video-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    border-color: #667eea;
    background: linear-gradient(135deg, #ffffff 0%, #f7faff 100%);
  }
  
  /* Add link icon on hover - positioned to the right */
  .video-item:hover .video-title a::after {
    content: '\f08e';
    font-family: 'Font Awesome 5 Free';
    font-weight: 900;
    position: relative;
    margin-left: 8px;
    color: #667eea;
    font-size: 0.85rem;
    opacity: 0;
    animation: fadeInSlide 0.3s ease forwards;
  }
  
  @keyframes fadeInSlide {
    from {
      opacity: 0;
      transform: translateX(-5px);
    }
    to {
      opacity: 0.7;
      transform: translateX(0);
    }
  }
  
  .video-title {
    font-weight: 600;
    margin: 0;
    font-size: 1.05rem;
  }
  
  .video-title a {
    color: #4a5568;
    text-decoration: none;
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    position: relative;
    cursor: pointer;
    padding: 4px 0;
    border-radius: 4px;
  }
  
  .video-title a:hover {
    color: #667eea;
    text-decoration: underline;
    text-decoration-color: #667eea;
    text-underline-offset: 3px;
  }
  
  .video-title a:hover .fa-play-circle {
    transform: scale(1.15);
    color: #ff0000 !important;
  }
  
  
  .video-meta {
    color: #6c757d;
    font-size: 0.9rem;
    margin-top: 4px;
  }
  
  .video-meta code {
    background: #f1f3f5;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 0.85rem;
  }
  
  /* Button styling matching analyze page */
  .vibe-button {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    border-radius: 8px;
    padding: 12px 24px;
    font-weight: 600;
    transition: all 0.3s ease;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    white-space: nowrap;
  }
  
  /* Fix for button in input group */
  .input-group .vibe-button {
    border-top-left-radius: 0 !important;
    border-bottom-left-radius: 0 !important;
    border-top-right-radius: 8px !important;
    border-bottom-right-radius: 8px !important;
    margin: 0;
    flex-shrink: 0;
  }
  
  .vibe-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
  }
  
  .vibe-button.small {
    padding: 8px 16px;
    font-size: 0.9rem;
  }
  
  .vibe-button.secondary {
    background: #6c757d;
  }
  
  .vibe-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
  
  /* Preloaded button state */
  .vibe-button.preloaded {
    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    opacity: 0.8;
    cursor: default;
    pointer-events: none;
  }
  
  .vibe-button.preloaded:hover {
    transform: none;
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
  }
  
  /* Jobs section styling */
  .jobs-section {
    background: #f8f9fa;
    border-radius: 12px;
    padding: 20px;
    margin-top: 20px;
  }
  
  .job-item {
    background: white;
    padding: 16px;
    border-radius: 8px;
    margin-bottom: 12px;
    border-left: 4px solid #667eea;
    animation: fadeIn 0.5s ease-in-out;
  }
  
  .job-type {
    font-weight: 600;
    color: #667eea;
    text-transform: uppercase;
    font-size: 0.75rem;
    letter-spacing: 0.5px;
  }
  
  .job-video-title {
    font-weight: 600;
    font-size: 1rem;
    color: #2d3748;
    margin: 8px 0 4px 0;
    display: block;
  }
  
  .job-video-title a {
    color: #2d3748;
    text-decoration: none;
    transition: all 0.2s ease;
  }
  
  .job-video-title a:hover {
    color: #667eea;
    text-decoration: underline;
  }
  
  .job-video-meta {
    font-size: 0.85rem;
    color: #6c757d;
    display: flex;
    gap: 15px;
    margin-top: 4px;
  }
  
  .job-video-meta span {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  
  .job-progress {
    display: inline-block;
    padding: 2px 8px;
    background: #e9ecef;
    border-radius: 12px;
    font-size: 0.85rem;
    margin-left: 8px;
  }
  
  .job-cancel-btn {
    padding: 4px 12px;
    font-size: 0.85rem;
    background: #dc3545;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    margin-left: 8px;
  }
  
  .job-cancel-btn:hover {
    background: #c82333;
    transform: scale(1.05);
  }
  
  .job-cancel-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  /* Loading spinner matching analyze page */
  .spinner-container {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 40px;
  }
  
  .loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(2px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10;
    border-radius: 12px;
    animation: fadeIn 0.3s ease-in;
  }
  
  .loading-overlay.hiding {
    animation: fadeOut 0.3s ease-out;
  }
  
  .video-list-container {
    position: relative;
    min-height: 200px;
  }
  
  .jobs-container-wrapper {
    position: relative;
    min-height: 100px;
  }
  
  /* Input group fixes */
  .input-group {
    display: flex;
    align-items: stretch;
    position: relative;
  }
  
  .input-group .form-control {
    border-top-right-radius: 0 !important;
    border-bottom-right-radius: 0 !important;
    border-right: none;
  }
  
  .input-group-text {
    background: white;
    border-right: none;
    border-top-left-radius: 0.5rem;
    border-bottom-left-radius: 0.5rem;
  }
  
  .input-group .form-control:focus {
    border-color: #667eea;
    box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
    z-index: 1;
  }
  
  /* Make sure the button doesn't get cut off */
  .input-group > .btn.vibe-button {
    position: relative;
    z-index: 2;
  }
  
  /* Channel info section */
  .channel-info-card {
    background: linear-gradient(135deg, #f5f7fa 0%, #f8f9ff 100%);
    border: 2px solid #e0e7ff;
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 20px;
    display: none;
  }
  
  .channel-info-card.active {
    display: block;
    animation: fadeIn 0.5s ease-in-out;
  }
  
  .channel-title-display {
    font-size: 1.6rem;
    font-weight: 700;
    color: #1a202c;
    font-family: 'Space Grotesk', 'Inter', sans-serif;
    letter-spacing: -0.5px;
    display: inline-flex;
    align-items: center;
    gap: 12px;
  }
  
  .channel-title-display i {
    font-size: 1.4rem;
    color: #667eea;
    opacity: 0.9;
  }
  
  .channel-title-display:hover i {
    transform: rotate(360deg);
    transition: transform 0.6s ease;
  }
  
  /* Empty state styling */
  .no-items-message {
    text-align: center;
    padding: 3rem 1rem;
    color: #6c757d;
  }
  
  .no-items-message i {
    font-size: 3rem;
    margin-bottom: 1rem;
    opacity: 0.5;
    display: block;
  }
  
  .no-items-message p {
    margin: 0;
    font-size: 1.1rem;
    font-weight: 500;
  }
  
  /* Channel tabs styling */
  .channel-tabs-container {
    border-bottom: 2px solid #e9ecef;
    margin-bottom: 20px;
  }
  
  .channel-tabs {
    border: none;
    gap: 8px;
  }
  
  .channel-tabs .nav-link {
    border: 2px solid transparent;
    border-radius: 12px 12px 0 0;
    padding: 10px 20px;
    color: #6c757d;
    background: #f8f9fa;
    margin-bottom: -2px;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .channel-tabs .nav-link:hover {
    background: #e9ecef;
    color: #495057;
  }
  
  .channel-tabs .nav-link.active {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-color: transparent;
  }
  
  .channel-tabs .nav-link .remove-channel {
    margin-left: 8px;
    opacity: 0.7;
    transition: opacity 0.2s;
  }
  
  .channel-tabs .nav-link:hover .remove-channel {
    opacity: 1;
  }
  
  .add-channel-tab {
    background: transparent !important;
    border: 2px dashed #dee2e6 !important;
    color: #6c757d !important;
  }
  
  .add-channel-tab:hover {
    border-color: #667eea !important;
    color: #667eea !important;
    background: rgba(102, 126, 234, 0.05) !important;
  }
  
  /* Channel input sliding */
  #channelInputSection {
    transition: all 0.4s ease;
    transform-origin: top;
    overflow: hidden;
  }
  
  #channelInputSection.collapsed {
    max-height: 0;
    margin-bottom: 0 !important;
    opacity: 0;
    transform: scaleY(0);
  }
  
  #channelInputSection.expanded {
    max-height: 200px;
    opacity: 1;
    transform: scaleY(1);
  }
  
  /* No channels state */
  .no-channels-message {
    text-align: center;
    padding: 40px;
    color: #6c757d;
  }
  
  .no-channels-message i {
    font-size: 3rem;
    opacity: 0.5;
    margin-bottom: 1rem;
  }
  
  /* Toast styling improvements */
  .toast-container {
    z-index: 1100;
  }
  
  .toast {
    animation: slideInRight 0.3s ease-out;
    backdrop-filter: blur(10px);
  }
  
  @keyframes slideInRight {
    from {
      transform: translateX(100%);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }
  
  @keyframes slideOutRight {
    from {
      transform: translateX(0);
      opacity: 1;
    }
    to {
      transform: translateX(100%);
      opacity: 0;
    }
  }
  
  /* Responsive adjustments */
  @media (max-width: 768px) {
    .stats-value {
      font-size: 1.25rem;
    }
    .stats-label {
      font-size: 0.8rem;
    }
    .video-item {
      flex-direction: column;
      align-items: flex-start;
      gap: 12px;
    }
    .vibe-button {
      width: 100%;
      justify-content: center;
    }
  }
  
  @media (max-width: 576px) {
    .stats-card {
      padding: 0.5rem;
    }
    .stats-value {
      font-size: 1.1rem;
    }
  }
</style>
{% endblock %}
{% block content %}
<div class="dashboard-page">
  <div class="container">
    <!-- Main Dashboard Card -->
    <div class="vibe-card dashboard-card mb-4">
      <div class="dashboard-inner-card">
        <div class="card-header-vibe d-flex justify-content-between align-items-center">
          <h3 class="mb-0">
            <span class="emoji-icon">📊</span> Your VibeCheck Dashboard
          </h3>
          <span class="badge" style="background: linear-gradient(45deg, #ffd700, #ff8a00); color: white; padding: 6px 14px; border-radius: 20px; font-weight: 700; font-size: 0.75rem;">PRO</span>
        </div>
        <div class="card-body">
        <!-- Channel Tabs -->
        <div class="channel-tabs-container mb-4">
          <ul class="nav nav-tabs channel-tabs" id="channelTabs" role="tablist">
            <!-- Tabs will be dynamically added here -->
            <li class="nav-item" role="presentation">
              <button class="nav-link add-channel-tab" id="addChannelTab" type="button">
                <i class="fas fa-plus-circle"></i> Add Channel
              </button>
            </li>
          </ul>
        </div>
        <!-- Channel Input Section (shown conditionally) -->
        <div class="mb-4" id="channelInputSection">
          <label for="channelInput" class="form-label fw-semibold">
            <i class="fas fa-tv me-2"></i>Channel URL or @handle
          </label>
          <div class="input-group">
            <span class="input-group-text">
              <i class="fab fa-youtube text-danger"></i>
            </span>
            <input type="text" id="channelInput" class="form-control form-control-lg" 
                   placeholder="https://www.youtube.com/@yourhandle or @yourhandle">
            <button id="loadChannelBtn" class="btn vibe-button" type="button">
              <span class="button-icon">🔍</span>
              <span class="button-text">Load Videos</span>
            </button>
          </div>
          <div class="form-text mt-2">
            <i class="fas fa-info-circle"></i> We'll list your recent uploads. Data is cached and updates are checked automatically every 60 seconds.
          </div>
        </div>

        <!-- Channel Info Card -->
        <div id="channelInfo" class="channel-info-card">
          <div class="d-flex justify-content-between align-items-center">
            <div>
              <span class="channel-title-display">
                <i class="fas fa-user-circle me-2"></i>
                <span id="channelTitle"></span>
              </span>
            <span class="badge ms-2" id="videoCount" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);"></span>
            </div>
            <button id="preloadAllBtn" class="vibe-button small pulse-animation">
              <span class="button-icon">⚡</span>
              <span class="button-text">Preload Last 10</span>
            </button>
          </div>
        </div>

        <!-- Video List Section -->
        <div class="mt-4">
          <h5 class="mb-3">
            <i class="fas fa-video me-2"></i>Your Videos
          </h5>
          <div class="video-list-container">
            <div class="video-list" id="videoList">
              <!-- Initial empty state -->
              <div class="no-items-message">
                <i class="fas fa-film"></i>
                <p>Select or add a channel to view videos</p>
              </div>
            </div>
            <div id="videoLoadingOverlay" class="loading-overlay" style="display: none;">
              <div class="text-center">
                <div class="spinner-border text-primary mb-3" role="status">
                  <span class="visually-hidden">Loading videos...</span>
                </div>
                <p class="text-muted">Loading videos...</p>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Jobs Section -->
        <div class="jobs-section mt-4">
          <h5 class="mb-3">
            <i class="fas fa-tasks me-2"></i>Background Jobs
          </h5>
          <div class="jobs-container-wrapper">
            <div id="jobsContainer">
              <!-- Jobs will be displayed here -->
            </div>
            <div id="jobsLoadingOverlay" class="loading-overlay" style="display: none;">
              <div class="text-center">
                <div class="spinner-border spinner-border-sm text-primary" role="status">
                  <span class="visually-hidden">Loading jobs...</span>
                </div>
              </div>
            </div>
          </div>
        </div>
        
      </div> <!-- End of card-body -->
    </div> <!-- End of dashboard-inner-card -->
  </div> <!-- End of vibe-card dashboard-card -->
  </div> <!-- End of container -->
</div> <!-- End of dashboard-page -->

<!-- Enhanced Toast Container -->
<div aria-live="polite" aria-atomic="true" class="position-relative">
  <div id="toastContainer" class="toast-container position-fixed top-0 end-0 p-3"></div>
</div>
{% endblock %}
{% block extra_js %}
<script>
const el = (id) => document.getElementById(id);

function escapeHtml(str) {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

// Enhanced toast system matching analyze page
function showToast(message, variant = 'info', delay = 3000) {
  const container = el('toastContainer');
  if (!container) return alert(message);
  
  const toast = document.createElement('div');
  
  // Define colors and icons for different variants with site theme
  const variants = {
    success: {
      gradient: 'linear-gradient(135deg, #10b981 0%, #059669 100%)',
      icon: '✅',
      textColor: 'text-white',
      borderColor: '#059669'
    },
    danger: {
      gradient: 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)',
      icon: '❌',
      textColor: 'text-white',
      borderColor: '#dc2626'
    },
    warning: {
      gradient: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)',
      icon: '⚠️',
      textColor: 'text-white',
      borderColor: '#d97706'
    },
    info: {
      gradient: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
      icon: 'ℹ️',
      textColor: 'text-white',
      borderColor: '#764ba2'
    }
  };
  
  const config = variants[variant] || variants.info;
  
  toast.className = `toast align-items-center ${config.textColor} border-0`;
  toast.setAttribute('role', 'alert');
  toast.setAttribute('aria-live', 'assertive');
  toast.setAttribute('aria-atomic', 'true');
  toast.style.minWidth = '350px';
  toast.style.background = config.gradient;
  toast.style.border = `2px solid ${config.borderColor}`;
  toast.style.borderRadius = '12px';
  toast.style.boxShadow = '0 8px 24px rgba(0, 0, 0, 0.15)';
  toast.style.backdropFilter = 'blur(10px)';
  
  toast.innerHTML = `
    <div class="d-flex align-items-center" style="padding: 8px;">
      <div class="toast-body d-flex align-items-center" style="font-weight: 500;">
        <span class="me-3" style="font-size: 1.3rem; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));">${config.icon}</span>
        <span style="font-size: 0.95rem; letter-spacing: 0.3px;">${escapeHtml(message)}</span>
      </div>
      <button type="button" class="btn-close btn-close-white me-2 m-auto" 
              style="opacity: 0.9; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));" 
              data-bs-dismiss="toast" aria-label="Close"></button>
    </div>`;
  
  container.appendChild(toast);
  
  // Add smooth entrance animation
  toast.style.animation = 'slideInRight 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
  toast.style.transformOrigin = 'top right';
  
  const t = new bootstrap.Toast(toast, { delay });
  t.show();
  
  toast.addEventListener('hidden.bs.toast', () => {
    toast.style.animation = 'slideOutRight 0.3s ease-in';
    setTimeout(() => toast.remove(), 300);
  });
}

async function fetchJSON(url, opts) {
  const res = await fetch(url, opts);
  const data = await res.json();
  if (!res.ok || !data.success) throw new Error(data.error || 'Request failed');
  return data;
}

// Keep last rendered list in memory to reduce flicker and enable diffing
let lastRenderedIds = [];
let lastRenderedJobs = {}; // Track job states to prevent re-rendering
let preloadedVideos = new Set(); // Track preloaded videos from server job status (source of truth)
// Note: We rely on server state via fetchJobs() to populate this Set
// The server maintains the actual cache status in Redis
let isLoadingVideos = false;
let isLoadingJobs = false;
let firstJobsLoad = true; // Track if this is the first jobs load

// Multi-channel support
let userChannels = []; // Array of channel objects
let activeChannelId = null; // Currently active channel
const MAX_CHANNELS = 5;

// Validate stored channels against actual database state
async function validateStoredChannels() {
  // If we have stored channels but they fail to load, clear them
  if (userChannels.length > 0) {
    try {
      // Try to load the first channel to see if it's valid
      const testChannel = userChannels[0];
      const response = await fetch(`/api/youtube/channel-videos?channel=${encodeURIComponent(testChannel.url || testChannel.id)}&max=1`);
      
      if (!response.ok) {
        // Channel doesn't exist or user doesn't have access
        console.log('Stored channels are invalid, clearing localStorage');
        userChannels = [];
        localStorage.removeItem('vibe:userChannels');
        localStorage.removeItem('vibe:lastChannel');
        renderChannelTabs();
      }
    } catch (e) {
      console.log('Could not validate channels:', e);
    }
  }
}
function renderVideoItem(v) {
  const div = document.createElement('div');
  div.className = 'video-item';
  div.style.opacity = '0';
  div.style.animation = 'fadeIn 0.5s ease-in-out forwards';
  
  // Format numbers with commas
  const formatNumber = (num) => (num || 0).toLocaleString();
  
  div.innerHTML = `
    <div class="flex-grow-1">
      <p class="video-title">
        <a href="/analyze/${v.id}" 
           class="text-decoration-none" 
           title="Click to analyze: ${escapeHtml(v.title || 'Untitled')}"
           data-bs-toggle="tooltip" 
           data-bs-placement="top">
          <i class="fas fa-play-circle" style="color: #ff0000; transition: all 0.2s ease;"></i>
          <span>${escapeHtml(v.title || 'Untitled')}</span>
        </a>
      </p>
      <div class="video-meta">
        <span class="me-3">
          <i class="fas fa-fingerprint me-1"></i>
          <code>${v.id}</code>
        </span>
        <span class="me-3">
          <i class="fas fa-eye me-1"></i>
          ${formatNumber(v.statistics?.views)} views
        </span>
        <span>
          <i class="fas fa-comment me-1"></i>
          ${formatNumber(v.statistics?.comments)} comments
        </span>
      </div>
    </div>
    <div>
      ${preloadedVideos.has(v.id) ? 
        `<button class="vibe-button small preloaded" data-video-id="${v.id}">
          <span class="button-icon">✅</span>
          <span class="button-text">Preloaded</span>
        </button>` :
        `<button class="vibe-button small" data-video-id="${v.id}">
          <span class="button-icon">🚀</span>
          <span class="button-text">Preload</span>
        </button>`
      }
    </div>
  `;
  
  const preloadBtn = div.querySelector('.vibe-button');
  
  // Only add click handler if not already preloaded
  if (!preloadedVideos.has(v.id)) {
    preloadBtn.addEventListener('click', async (e) => {
      e.preventDefault();
      preloadBtn.disabled = true;
      preloadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Queuing...';
      await queuePreload(v.id);
      preloadBtn.innerHTML = '<i class="fas fa-check"></i> Queued';
      
      // Mark as preloaded (temporarily, will be confirmed by server)
      preloadedVideos.add(v.id);
      
      // After a delay, update to preloaded state
      setTimeout(() => {
        preloadBtn.classList.add('preloaded');
        preloadBtn.innerHTML = '<span class="button-icon">✅</span><span class="button-text">Preloaded</span>';
        preloadBtn.disabled = true;
      }, 2000);
    });
  }
  
  // Initialize Bootstrap tooltip for the video link
  setTimeout(() => {
    const tooltipTrigger = div.querySelector('[data-bs-toggle="tooltip"]');
    if (tooltipTrigger) {
      new bootstrap.Tooltip(tooltipTrigger);
    }
  }, 100);
  
  return div;
}

async function loadChannel(opts={silent:false}) {
  const channel = el('channelInput').value.trim();
  if (!channel) {
    showToast('Please enter a channel URL or @handle', 'warning');
    return;
  }
  
  const loadBtn = el('loadChannelBtn');
  const originalBtnContent = loadBtn.innerHTML;
  
  if (!opts.silent) {
    isLoadingVideos = true;
    loadBtn.disabled = true;
    loadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
    
    // Show loading overlay
    const loadingOverlay = el('videoLoadingOverlay');
    if (loadingOverlay) {
      loadingOverlay.style.display = 'flex';
    }
    
    // Clear existing content
    el('videoList').innerHTML = '';
  }
  
  try {
    const data = await fetchJSON(`/api/youtube/channel-videos?channel=${encodeURIComponent(channel)}&max=100`);
    
    // Show channel info with animation
    const channelInfo = el('channelInfo');
    channelInfo.classList.add('channel-info-card', 'active');
    el('channelTitle').innerText = data.channel.title;
    el('videoCount').innerText = `${data.count} videos`;
    
    try { localStorage.setItem('vibe:lastChannel', channel); } catch (e) {}
    
    // Only re-render if changed (simple diff on IDs)
    const ids = data.videos.map(v => v.id);
    const changed = ids.length !== lastRenderedIds.length || ids.some((id, i) => id !== lastRenderedIds[i]);
    
    if (changed || !opts.silent) {
      const list = el('videoList');
      list.innerHTML = '';
      
      if (data.videos.length === 0) {
        list.innerHTML = `
          <div class="no-items-message">
            <i class="fas fa-video-slash"></i>
            <p>No videos found</p>
          </div>
        `;
      } else {
        // Stagger the animation of video items
        data.videos.forEach((v, index) => {
          setTimeout(() => {
            list.appendChild(renderVideoItem(v));
          }, index * 50); // 50ms delay between each item
        });
      }
      
      lastRenderedIds = ids;
      if (!opts.silent) {
        showToast(`Loaded ${data.count} videos from ${data.channel.title}`, 'success', 2000);
      }
    }
  } catch (e) {
    if (!opts.silent) {
      el('videoList').innerHTML = `
        <div class="alert alert-danger" role="alert">
          <i class="fas fa-exclamation-triangle me-2"></i>
          <strong>Error loading channel:</strong> ${escapeHtml(e.message || 'Unknown error')}
        </div>
      `;
      showToast(e.message || 'Failed to load channel', 'danger', 4000);
    }
  } finally {
    if (!opts.silent) {
      isLoadingVideos = false;
      loadBtn.disabled = false;
      loadBtn.innerHTML = originalBtnContent;
      
      // Hide loading overlay
      const loadingOverlay = el('videoLoadingOverlay');
      if (loadingOverlay) {
        loadingOverlay.style.display = 'none';
      }
    }
  }
}

async function queuePreload(videoId) {
  try {
    const data = await fetchJSON(`/api/preload/comments/${videoId}`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ target_comments: null })
    });
    showToast(`Preload queued for ${videoId}`, 'success');
    fetchJobs();
  } catch (e) {
    showToast(e.message || 'Failed to queue preload', 'danger');
  }
}

// Cancel a job
async function cancelJob(jobId, videoId) {
  try {
    // Disable the cancel button immediately
    const cancelBtn = document.querySelector(`[data-cancel-job-id="${jobId}"]`);
    if (cancelBtn) {
      cancelBtn.disabled = true;
      cancelBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
    }
    
    const data = await fetchJSON(`/api/jobs/cancel/${jobId}`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'}
    });
    
    showToast(`Job cancelled for ${videoId || jobId}`, 'info');
    
    // Force immediate refresh of jobs
    setTimeout(fetchJobs, 500);
  } catch (e) {
    showToast(e.message || 'Failed to cancel job', 'danger');
    // Re-enable button on error
    const cancelBtn = document.querySelector(`[data-cancel-job-id="${jobId}"]`);
    if (cancelBtn) {
      cancelBtn.disabled = false;
      cancelBtn.innerHTML = '<i class="fas fa-times"></i> Cancel';
    }
  }
}

async function preloadLastTen() {
  const preloadAllBtn = el('preloadAllBtn');
  const originalContent = preloadAllBtn.innerHTML;
  
  preloadAllBtn.disabled = true;
  preloadAllBtn.classList.remove('pulse-animation');
  preloadAllBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Queuing videos...';
  
  // Get only the first 10 video buttons that aren't already preloaded
  const allButtons = Array.from(document.querySelectorAll('.vibe-button[data-video-id]:not(.preloaded)'));
  const buttons = allButtons.slice(0, 10); // Take only the first 10 non-preloaded
  
  if (buttons.length === 0) {
    showToast('No videos to preload', 'warning');
    preloadAllBtn.disabled = false;
    preloadAllBtn.innerHTML = originalContent;
    return;
  }
  
  const totalToQueue = buttons.length;
  showToast(`Queuing ${totalToQueue} videos for preload...`, 'info');
  
  let queued = 0;
  for (const btn of buttons) {
    const vid = btn.getAttribute('data-video-id');
    if (vid) {
      await queuePreload(vid);
      queued++;
      preloadAllBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Queued ${queued}/${totalToQueue}`;
    }
  }
  
  preloadAllBtn.innerHTML = '<i class="fas fa-check"></i> Queued!';
  showToast(`Successfully queued ${queued} videos for preload`, 'success', 3000);
  
  setTimeout(() => {
    preloadAllBtn.disabled = false;
    preloadAllBtn.classList.add('pulse-animation');
    preloadAllBtn.innerHTML = originalContent;
  }, 3000);
}

// Event listeners with enhanced feedback
el('loadChannelBtn').addEventListener('click', () => {
  if (!isLoadingVideos) {
    loadChannel({silent:false});
  }
});

el('preloadAllBtn').addEventListener('click', preloadLastTen);

// Enter key support for channel input
el('channelInput').addEventListener('keypress', (e) => {
  if (e.key === 'Enter' && !isLoadingVideos) {
    loadChannel({silent:false});
  }
});

// Fetch and display background jobs with smart updates
async function fetchJobs(filterCompleted = false, forceRender = false) {
  try {
    // Show loading overlay only on first load
    if (firstJobsLoad) {
      const jobsLoadingOverlay = el('jobsLoadingOverlay');
      if (jobsLoadingOverlay) {
        jobsLoadingOverlay.style.display = 'flex';
      }
      isLoadingJobs = true;
    }
    
    const data = await fetchJSON('/api/jobs/status');
    const c = el('jobsContainer');
    
    if (!c) {
      console.error('jobsContainer element not found!');
      return;
    }
    
    console.log('Fetched jobs:', data.jobs); // Debug logging
    if (data.jobs && data.jobs.length > 0) {
      console.log('First job details:', data.jobs[0]);
      console.log('Job has metadata?', data.jobs[0].video_metadata);
    }
    
    // Filter out completed/cancelled jobs if requested (e.g., on initial load)
    let jobs = data.jobs;
    if (filterCompleted) {
      const beforeFilter = jobs.length;
      jobs = jobs.filter(j => 
        j.status === 'queued' || 
        j.status === 'pending' || 
        j.status === 'running' || 
        j.status === 'fetching' || 
        j.status === 'syncing'
      );
      console.log(`Filtered ${beforeFilter} jobs to ${jobs.length} active jobs`);
    }
    
    // Handle empty state
    if (!jobs.length) {
      console.log('No jobs to display');
      c.innerHTML = `
        <div class="no-items-message">
          <i class="fas fa-check-circle"></i>
          <p>No active jobs</p>
        </div>
      `;
      lastRenderedJobs = {};
      return;
    }
    
    console.log('Displaying', jobs.length, 'jobs');
    
    // Deduplicate by job_id and track preloaded videos
    const seen = new Set();
    const unique = [];
    for (const j of jobs) {
      if (!seen.has(j.job_id)) {
        seen.add(j.job_id);
        unique.push(j);
        
        // Track completed preload jobs from server state
        if (j.job_type === 'preload' && j.status === 'completed' && j.video_id) {
          preloadedVideos.add(j.video_id);
        }
      }
    }
    
    // Check if we need to do a full re-render
    const currentJobIds = unique.map(j => j.job_id);
    const previousJobIds = Object.keys(lastRenderedJobs);
    const needsFullRender = forceRender || 
                           currentJobIds.length !== previousJobIds.length ||
                           currentJobIds.some(id => !lastRenderedJobs[id]);
    
    console.log('Current job IDs:', currentJobIds);
    console.log('Previous job IDs:', previousJobIds);
    console.log('Force render:', forceRender);
    console.log('Needs full render:', needsFullRender);
    
    if (needsFullRender) {
      // New jobs added or structure changed - do full render
      console.log('Performing full render of', unique.length, 'jobs');
      c.innerHTML = '';
      unique.forEach(j => {
        console.log('Creating element for job:', j.job_id, 'status:', j.status);
        console.log('Full job data:', j);
        const jobEl = createJobElement(j);
        c.appendChild(jobEl);
        lastRenderedJobs[j.job_id] = {
          status: j.status,
          progress: j.progress
        };
      });
    } else {
      // Update existing jobs in place
      unique.forEach(j => {
        const previous = lastRenderedJobs[j.job_id];
        const jobEl = document.querySelector(`[data-job-id="${j.job_id}"]`);
        
        if (jobEl && (previous.status !== j.status || previous.progress !== j.progress)) {
          // Only update the parts that changed
          updateJobElement(jobEl, j, previous);
          lastRenderedJobs[j.job_id] = {
            status: j.status,
            progress: j.progress
          };
        }
      });
    }
    
    // Remove jobs that no longer exist
    previousJobIds.forEach(id => {
      if (!currentJobIds.includes(id)) {
        const jobEl = document.querySelector(`[data-job-id="${id}"]`);
        if (jobEl) {
          jobEl.style.animation = 'fadeOut 0.3s ease-out';
          setTimeout(() => jobEl.remove(), 300);
        }
        delete lastRenderedJobs[id];
      }
    });
    
  } catch (e) {
    console.error('Error fetching jobs:', e);
    const c = el('jobsContainer');
    if (c && firstJobsLoad) {
      c.innerHTML = `
        <div class="alert alert-warning" role="alert">
          <i class="fas fa-exclamation-triangle me-2"></i>
          Error loading jobs. Please refresh the page.
        </div>
      `;
    }
  } finally {
    // Hide loading overlay and mark first load as complete
    if (firstJobsLoad) {
      firstJobsLoad = false;
      isLoadingJobs = false;
      const jobsLoadingOverlay = el('jobsLoadingOverlay');
      if (jobsLoadingOverlay) {
        setTimeout(() => {
          jobsLoadingOverlay.style.display = 'none';
        }, 300); // Small delay for smooth transition
      }
    }
  }
}

// Create a job element with enhanced video metadata
function createJobElement(j) {
  console.log('Creating job element for:', j);
  const div = document.createElement('div');
  div.className = 'job-item';
  div.setAttribute('data-job-id', j.job_id);
  div.style.animation = 'fadeIn 0.3s ease-in';
  
  const isSync = j.job_type === 'channel_sync';
  const statusIcon = getStatusIcon(j.status);
  const statusColor = getStatusColor(j.status);
  const isCancellable = j.status === 'running' || j.status === 'pending' || j.status === 'queued';
  const isCompleted = j.status === 'completed';
  
  // Format numbers with commas
  const formatNumber = (num) => (num || 0).toLocaleString();
  
  // Build video metadata display - always show video info if we have a video_id
  let videoInfo = '';
  if (j.video_id) {
    // Check if we have metadata
    const hasMetadata = j.video_metadata && j.video_metadata.title;
    const videoTitle = hasMetadata ? j.video_metadata.title : `Video ${j.video_id}`;
    const truncatedTitle = videoTitle.length > 60 ? videoTitle.substring(0, 60) + '...' : videoTitle;
    
    // Always show the video title/ID as a link if completed
    videoInfo = `
      <div class="job-video-title">
        ${isCompleted ? 
          `<a href="/analyze/${j.video_id}" title="Click to view analysis">
            <i class="fas fa-chart-line me-1"></i>${escapeHtml(truncatedTitle)}
          </a>` : 
          `<i class="fas fa-video me-1"></i>${escapeHtml(truncatedTitle)}`
        }
      </div>
    `;
    
    // Add metadata if available
    if (hasMetadata && j.video_metadata) {
      const meta = j.video_metadata;
      videoInfo += `
        <div class="job-video-meta">
          ${meta.views ? `<span><i class="fas fa-eye"></i> ${formatNumber(meta.views)} views</span>` : ''}
          ${meta.comments ? `<span><i class="fas fa-comment"></i> ${formatNumber(meta.comments)} comments</span>` : ''}
          ${meta.published ? `<span><i class="fas fa-calendar"></i> ${meta.published.split('T')[0]}</span>` : ''}
        </div>
      `;
    }
  }
  
  // Create HTML with video info prominently displayed
  const videoIdDisplay = j.video_id ? `<code class="ms-2">${j.video_id}</code>` : '';
  const analyzeLink = isCompleted && j.video_id ? 
    `<a href="/analyze/${j.video_id}" class="text-decoration-none fw-bold"><i class="fas fa-chart-line me-1"></i>View Analysis</a>` : '';
  
  div.innerHTML = `
    <div>
      <div class="d-flex justify-content-between align-items-center">
        <div class="flex-grow-1">
          <div>
            <span class="job-type">
              ${isSync ? '<i class="fas fa-sync"></i> CHANNEL SYNC' : '<i class="fas fa-download"></i> COMMENT PRELOAD'}
            </span>
            ${videoIdDisplay}
          </div>
          ${j.video_id ? `
            <div class="mt-2">
              ${isCompleted ? analyzeLink : `<span class="text-muted"><i class="fas fa-video me-1"></i>Video: ${j.video_id}</span>`}
            </div>
          ` : ''}
        </div>
        <div class="d-flex align-items-center job-status-container">
          <span class="badge bg-${statusColor} me-2 job-status-badge">
            ${statusIcon} ${j.status}
          </span>
          <div class="job-progress-container">
            ${j.status === 'running' ? `
              <div class="progress" style="width: 100px; height: 20px;">
                <div class="progress-bar progress-bar-striped progress-bar-animated bg-primary" 
                     role="progressbar" 
                     style="width: ${j.progress || 0}%" 
                     aria-valuenow="${j.progress || 0}" 
                     aria-valuemin="0" 
                     aria-valuemax="100">
                  ${j.progress || 0}%
                </div>
              </div>
            ` : j.status !== 'completed' ? `<span class="job-progress">${j.progress || 0}%</span>` : ''}
          </div>
          ${isCancellable ? `
            <button class="job-cancel-btn" 
                    data-cancel-job-id="${j.job_id}"
                    onclick="cancelJob('${j.job_id}', '${j.video_id || j.channel_id || ''}')">
              <i class="fas fa-times"></i> Cancel
            </button>
          ` : ''}
          ${isCompleted && j.video_id ? `
            <a href="/analyze/${j.video_id}" class="btn btn-sm btn-success ms-2" 
               style="padding: 4px 12px; font-size: 0.85rem;">
              <i class="fas fa-external-link-alt"></i> View
            </a>
          ` : ''}
        </div>
      </div>
      ${videoInfo}
    </div>
  `;
  
  return div;
}

// Update only the changed parts of a job element
function updateJobElement(jobEl, j, previous) {
  const statusBadge = jobEl.querySelector('.job-status-badge');
  const progressContainer = jobEl.querySelector('.job-progress-container');
  const statusContainer = jobEl.querySelector('.job-status-container');
  
  // Update status if changed
  if (previous.status !== j.status) {
    const statusIcon = getStatusIcon(j.status);
    const statusColor = getStatusColor(j.status);
    const isCancellable = j.status === 'running' || j.status === 'pending' || j.status === 'queued';
    const wasCancellable = previous.status === 'running' || previous.status === 'pending' || previous.status === 'queued';
    const isCompleted = j.status === 'completed';
    
    // Animate the status change
    statusBadge.style.animation = 'pulse 0.5s ease-in-out';
    statusBadge.className = `badge bg-${statusColor} me-2 job-status-badge`;
    statusBadge.innerHTML = `${statusIcon} ${j.status}`;
    
    // Update progress display type based on status
    if (j.status === 'running' && previous.status !== 'running') {
      progressContainer.innerHTML = `
        <div class="progress" style="width: 100px; height: 20px;">
          <div class="progress-bar progress-bar-striped progress-bar-animated bg-primary" 
               role="progressbar" 
               style="width: ${j.progress || 0}%" 
               aria-valuenow="${j.progress || 0}" 
               aria-valuemin="0" 
               aria-valuemax="100">
            ${j.progress || 0}%
          </div>
        </div>
      `;
    } else if (j.status === 'completed') {
      // Clear progress for completed jobs
      progressContainer.innerHTML = '';
    } else if (j.status !== 'running' && previous.status === 'running') {
      progressContainer.innerHTML = `<span class="job-progress">${j.progress || 0}%</span>`;
    }
    
    // Handle cancel button visibility
    const existingCancelBtn = jobEl.querySelector('.job-cancel-btn');
    const existingViewBtn = jobEl.querySelector('.btn-success');
    
    if (!isCancellable && wasCancellable && existingCancelBtn) {
      // Remove cancel button when job is no longer cancellable
      existingCancelBtn.style.animation = 'fadeOut 0.3s ease-out';
      setTimeout(() => existingCancelBtn.remove(), 300);
    } else if (isCancellable && !wasCancellable && !existingCancelBtn) {
      // Add cancel button when job becomes cancellable
      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'job-cancel-btn';
      cancelBtn.setAttribute('data-cancel-job-id', j.job_id);
      cancelBtn.innerHTML = '<i class="fas fa-times"></i> Cancel';
      cancelBtn.onclick = () => cancelJob(j.job_id, j.video_id || j.channel_id || '');
      statusContainer.appendChild(cancelBtn);
    }
    
    // Add View button for completed jobs
    if (isCompleted && j.video_id && !existingViewBtn) {
      const viewBtn = document.createElement('a');
      viewBtn.href = `/analyze/${j.video_id}`;
      viewBtn.className = 'btn btn-sm btn-success ms-2';
      viewBtn.style.cssText = 'padding: 4px 12px; font-size: 0.85rem;';
      viewBtn.innerHTML = '<i class="fas fa-external-link-alt"></i> View';
      statusContainer.appendChild(viewBtn);
      
      // Also update the video title to be a link
      const titleEl = jobEl.querySelector('.job-video-title');
      if (titleEl && !titleEl.querySelector('a')) {
        const currentText = titleEl.textContent;
        titleEl.innerHTML = `<a href="/analyze/${j.video_id}" title="View analysis"><i class="fas fa-chart-line me-1"></i>${escapeHtml(currentText)}</a>`;
      }
    }
  }
  
  // Update progress if changed (for running jobs)
  if (j.status === 'running' && previous.progress !== j.progress) {
    const progressBar = progressContainer.querySelector('.progress-bar');
    if (progressBar) {
      progressBar.style.width = `${j.progress || 0}%`;
      progressBar.setAttribute('aria-valuenow', j.progress || 0);
      progressBar.textContent = `${j.progress || 0}%`;
    }
  } else if (j.status !== 'running' && j.status !== 'completed') {
    const progressSpan = progressContainer.querySelector('.job-progress');
    if (progressSpan && progressSpan.textContent !== `${j.progress || 0}%`) {
      progressSpan.textContent = `${j.progress || 0}%`;
    }
  }
}

// Helper functions for status
function getStatusIcon(status) {
  const icons = {
    'completed': '✅',
    'failed': '❌',
    'running': '🔄',
    'pending': '⏳',
    'queued': '⏳',
    'cancelled': '🚫'
  };
  return icons[status] || '⏳';
}

function getStatusColor(status) {
  const colors = {
    'completed': 'success',
    'failed': 'danger',
    'running': 'primary',
    'pending': 'secondary',
    'queued': 'secondary',
    'cancelled': 'warning'
  };
  return colors[status] || 'secondary';
}

// Clear old completed/cancelled jobs
async function clearOldJobs() {
  try {
    const data = await fetchJSON('/api/jobs/clear-old', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'}
    });
    if (data.cleared && data.cleared > 0) {
      console.log(`Cleared ${data.cleared} old jobs`);
    }
  } catch (e) {
    // Silently ignore if endpoint doesn't exist yet
    console.log('Could not clear old jobs:', e.message);
  }
}

// Initialize channel management
function initChannels() {
  // Load saved channels from localStorage
  try {
    const saved = localStorage.getItem('vibe:userChannels');
    if (saved) {
      userChannels = JSON.parse(saved);
      // Validate that these channels still exist
      // If we have channels in localStorage but the page loads with empty state,
      // it means the database was cleared and we should clear localStorage too
      validateStoredChannels();
    }
  } catch (e) {
    console.log('Could not load saved channels');
  }
  
  // Clear video list and channel info if no channels
  if (userChannels.length === 0) {
    el('videoList').innerHTML = `
      <div class="no-items-message">
        <i class="fas fa-film"></i>
        <p>Select or add a channel to view videos</p>
      </div>
    `;
    el('channelInfo').classList.remove('active');
    // Clear any stored last channel
    try {
      localStorage.removeItem('vibe:lastChannel');
    } catch (e) {}
  }
  
  // Render channel tabs (this will also manage visibility)
  renderChannelTabs();
  
  // Manage input section visibility based on channels
  const inputSection = el('channelInputSection');
  if (inputSection) {
    if (userChannels.length > 0) {
      // Have channels - hide the input section
      inputSection.classList.add('collapsed');
      inputSection.classList.remove('expanded');
    } else {
      // No channels - show the input section
      inputSection.classList.remove('collapsed');
      inputSection.classList.add('expanded');
    }
  }
  
  // Set up add channel button
  el('addChannelTab').addEventListener('click', () => {
    if (userChannels.length >= MAX_CHANNELS) {
      showToast(`Maximum ${MAX_CHANNELS} channels allowed`, 'warning');
      return;
    }
    showAddChannelDialog();
  });
}

// Render channel tabs
function renderChannelTabs() {
  const tabsContainer = el('channelTabs');
  const addBtn = el('addChannelTab').parentElement;
  
  // Clear existing tabs except add button
  while (tabsContainer.firstChild && tabsContainer.firstChild !== addBtn) {
    tabsContainer.removeChild(tabsContainer.firstChild);
  }
  
  // Add tabs for each channel
  userChannels.forEach((channel, index) => {
    const li = document.createElement('li');
    li.className = 'nav-item';
    li.setAttribute('role', 'presentation');
    
    const button = document.createElement('button');
    button.className = 'nav-link' + (channel.id === activeChannelId ? ' active' : '');
    button.type = 'button';
    button.innerHTML = `
      <i class="fab fa-youtube"></i>
      <span>${escapeHtml(channel.title)}</span>
      <span class="remove-channel" data-channel-id="${channel.id}">
        <i class="fas fa-times-circle"></i>
      </span>
    `;
    
    button.addEventListener('click', (e) => {
      if (e.target.closest('.remove-channel')) {
        removeChannel(channel.id);
      } else {
        switchToChannel(channel.id);
      }
    });
    
    li.appendChild(button);
    tabsContainer.insertBefore(li, addBtn);
  });
  
  // Manage input section visibility
  const inputSection = el('channelInputSection');
  if (inputSection) {
    if (userChannels.length > 0) {
      inputSection.classList.add('collapsed');
      inputSection.classList.remove('expanded');
    } else {
      inputSection.classList.remove('collapsed');
      inputSection.classList.add('expanded');
    }
  }
  
  // Clear video list if no channels
  if (userChannels.length === 0) {
    el('videoList').innerHTML = `
      <div class="no-items-message">
        <i class="fas fa-film"></i>
        <p>Select or add a channel to view videos</p>
      </div>
    `;
    el('channelInfo').classList.remove('active');
  } else if (!activeChannelId) {
    // Auto-select first channel if none selected
    switchToChannel(userChannels[0].id);
  }
}

// Show add channel dialog
function showAddChannelDialog() {
  // If we have channels, show the input section
  const inputSection = el('channelInputSection');
  
  if (userChannels.length > 0) {
    // Slide down the input section
    inputSection.classList.remove('collapsed');
    inputSection.classList.add('expanded');
    
    // Focus the input
    el('channelInput').focus();
    el('channelInput').value = '';
    
    // Update button to say "Add Channel"
    const loadBtn = el('loadChannelBtn');
    loadBtn.innerHTML = '<span class="button-icon">➕</span><span class="button-text">Add Channel</span>';
    
    // Change button behavior to add channel
    loadBtn.onclick = async () => {
      const channelUrl = el('channelInput').value.trim();
      if (!channelUrl) {
        showToast('Please enter a channel URL or @handle', 'warning');
        return;
      }
      await addChannelFromInput(channelUrl);
    };
  } else {
    // For first channel, the input is already visible
    el('channelInput').focus();
  }
}

// Add channel from input
async function addChannelFromInput(channelUrl) {
  if (userChannels.length >= MAX_CHANNELS) {
    showToast(`Maximum ${MAX_CHANNELS} channels allowed`, 'warning');
    return;
  }
  
  // Check if already added by URL
  if (userChannels.find(c => c.url === channelUrl || c.handle === channelUrl)) {
    showToast('Channel already added', 'warning');
    return;
  }
  
  // Show loading state
  const loadBtn = el('loadChannelBtn');
  const originalContent = loadBtn.innerHTML;
  loadBtn.disabled = true;
  loadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Adding...';
  
  try {
    // Load channel to get proper title
    const response = await fetch(`/api/youtube/channel-videos?channel=${encodeURIComponent(channelUrl)}&max=10`);
    const data = await response.json();
    
    if (!data.success) {
      throw new Error(data.error || 'Failed to load channel');
    }
    
    // Check if already added by ID
    if (userChannels.find(c => c.id === data.channel.id)) {
      showToast('Channel already added', 'warning');
      return;
    }
    
    // Add to channels with proper data
    const newChannel = {
      id: data.channel.id,
      title: data.channel.title,
      handle: data.channel.handle,
      url: channelUrl
    };
    
    userChannels.push(newChannel);
    saveChannels();
    renderChannelTabs();
    
    // Hide input section if we now have channels
    el('channelInputSection').classList.add('collapsed');
    el('channelInputSection').classList.remove('expanded');
    
    // Switch to the new channel
    switchToChannel(newChannel.id);
    showToast(`Added: ${newChannel.title}`, 'success');
    
  } catch (error) {
    showToast(error.message || 'Failed to add channel', 'danger');
  } finally {
    loadBtn.disabled = false;
    loadBtn.innerHTML = originalContent;
  }
}

// Remove channel
async function removeChannel(channelId) {
  if (confirm('Remove this channel from your dashboard? This will delete all associated videos and analysis data.')) {
    try {
      // Call API to delete all channel data
      const response = await fetch(`/api/channel/${channelId}/delete`, {
        method: 'DELETE',
        headers: {'Content-Type': 'application/json'}
      });
      
      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.error || 'Failed to delete channel data');
      }
      
      // Remove from local storage
      userChannels = userChannels.filter(c => c.id !== channelId);
      saveChannels();
      renderChannelTabs();
      
      if (activeChannelId === channelId) {
        activeChannelId = null;
        el('videoList').innerHTML = '';
        el('channelInfo').classList.remove('active');
        
        if (userChannels.length > 0) {
          switchToChannel(userChannels[0].id);
        } else {
          // No channels left - show the input section and reset button
          const inputSection = el('channelInputSection');
          if (inputSection) {
            inputSection.classList.remove('collapsed');
            inputSection.classList.add('expanded');
          }
          
          // Reset button to Load Channel
          const loadBtn = el('loadChannelBtn');
          if (loadBtn) {
            loadBtn.innerHTML = '<span class="button-icon">🎬</span><span class="button-text">Load Channel</span>';
          }
        }
      }
      
      // Show success with details
      let message = 'Channel removed';
      if (data.deleted_videos > 0 || data.deleted_jobs > 0) {
        message += ` (${data.deleted_videos || 0} videos, ${data.deleted_jobs || 0} jobs deleted)`;
      }
      showToast(message, 'success');
      
    } catch (error) {
      console.error('Error removing channel:', error);
      showToast(error.message || 'Failed to remove channel', 'danger');
    }
  }
}

// Switch to channel
function switchToChannel(channelId) {
  const channel = userChannels.find(c => c.id === channelId);
  if (!channel) return;
  
  activeChannelId = channelId;
  
  // Update tabs
  document.querySelectorAll('.channel-tabs .nav-link').forEach(tab => {
    tab.classList.remove('active');
    if (tab.querySelector(`[data-channel-id="${channelId}"]`)) {
      tab.classList.add('active');
    }
  });
  
  // Load channel videos
  el('channelInput').value = channel.url || channel.id;
  loadChannel({silent: false});
}

// Save channels to localStorage
function saveChannels() {
  try {
    localStorage.setItem('vibe:userChannels', JSON.stringify(userChannels));
  } catch (e) {
    console.log('Could not save channels');
  }
}

// Auto-load last channel from localStorage and start polling
window.addEventListener('DOMContentLoaded', () => {
  // Initialize multi-channel support
  initChannels();
  
  // Wire up the main Load Channel button
  const loadBtn = el('loadChannelBtn');
  if (loadBtn) {
    loadBtn.onclick = async () => {
      const channelUrl = el('channelInput').value.trim();
      if (!channelUrl) {
        showToast('Please enter a channel URL or @handle', 'warning');
        return;
      }
      
      if (userChannels.length === 0) {
        // First channel - use the new add function
        await addChannelFromInput(channelUrl);
      } else {
        // Already have channels - just load normally
        loadChannel({silent: false});
      }
    };
  }
  
  // Legacy single-channel support - disabled to prevent unwanted loading
  // Only populate the input if there's a stored value but don't load
  if (userChannels.length === 0) {
    const last = localStorage.getItem('vibe:lastChannel');
    if (last) {
      // Just populate the input, don't load
      el('channelInput').value = last;
    }
  }
  
  // Clear the rendered jobs tracker on page load to force fresh render
  lastRenderedJobs = {};
  
  // Fetch jobs immediately on page load with force render
  console.log('Initializing jobs fetch...');
  setTimeout(() => {
    fetchJobs(false, true); // Show all jobs initially with forced render
  }, 500); // Small delay to ensure page is fully loaded
  
  // Temporarily disabled to debug job display
  // setTimeout(() => {
  //   clearOldJobs().then(() => {
  //     console.log('Old jobs cleared');
  //   });
  // }, 1000);
  
  // Poll for channel updates every 60s only if channels exist and one is active
  setInterval(() => {
    if (userChannels.length > 0 && activeChannelId && el('channelInput').value.trim()) {
      loadChannel({silent:true});
    }
  }, 60000);
});

// Regular polling without filtering
setInterval(() => fetchJobs(false), 2000);
</script>
{% endblock %}
